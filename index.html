<html lang="en"><head>
  <meta charset="UTF-8">
  <title>Canvas Multiple Image Warp and Crop</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.11.0/dist/pptxgen.bundle.js"></script>
  <style>
    canvas {
      border: 1px solid black;
      display: block;
      margin-top: 10px;
    }
    button, select {
      margin: 5px 10px 10px 0;
      padding: 5px 15px;
      font-size: 16px;
    }
    img{
        /* width: 210mm; */
        width:2in;
        /* height: 297mm; */
        height: auto;
        /* page-break-after: always; */
      }
    @media print{
      body > div:not(:nth-of-type(3)), button, select, input, h3, canvas, label, span{
        display: none;
      }      
      img{
        width: 100%;
        height:auto;
      }
       
      body{
        display: block;
      }
      @page {
        size: auto;
        /* size: A4;         */
        margin: 10mm; /* leave room for printer margins */
      }
      /* td{
        display: block;
      } */
    }
    @page{
      padding:0;
      margin:0;
    }
  </style>
</head>
<body ondrop="dropHandler(event);" ondragover="dragOverHandler(event);" style="
    display: flex;    
">

  <div style="
    min-width: 7in;max-width: 7in;
"><h3>Upload Images</h3>
  <input type="file" id="upload" multiple="">
  <select id="imageSelector"></select>
  <!-- IMAGE PROCESSING -->
<fieldset>
  <legend>üñºÔ∏è Image Processing</legend>
  <button id="warpBtn">Warp Image</button>
  <button id="removePointsBtn">Show Remove Points</button>
  <button id="rotate">Rotate Canvas Clockwise</button>
  <button onclick="applyContrastStretching(true);">Auto Light Image Enhancement</button>
  <button id="sharpenImage">Image Sharpening Kernel</button>  
  <button onclick="applyMagicFilter()">Enhance Contrast (Histogram Equalization)</button>  
  <button onclick="applyBiHistogramEqualizationWithEdgePreservation()">apply Bi Histogram Equalization</button>
  <button onclick="adaptiveHistogramEqualization()">Adaptive Histogram Equalization (CLAHE)</button>    
  <button onclick="adaptiveHistogramEqualizationReinhard()">adaptive Histogram Equalization Reinhard</button>    
  <button onclick="dualGammaCLAHE(64, 40, 0.5, 1.5);">Dual Exposure Clahe</button>    
  <button onclick="enhancePhoto(canvas, 1.15, 1.0);">Enhance Photo using Unsharp Masking</button>
  <button onclick="applyGammaCorrection()">Apply Gamma Correction</button>
  <button onclick="gradientShadowRemovalWithGuidedFilter(document.querySelector('canvas'));">Gradient Shadow Removal</button>  
  <button onclick="edgeAwareAdaptiveThresholding()">edgeAware Adaptive Thresholding</button>
  <button onclick="laplacianEdgeAwareEnhancement({
    edgeStrength: 1.2,
    bilateralRadius: 2,
    sigmaSpatial: 2.0,
    sigmaRange: 20.0,
    adaptiveScaling: true,
    edgeSharpness: 0.1
});">edgeAware Laplacian Filter</button>
  <button onclick="intelligentEdgeAwareThresholding()">intelligent Edge Aware Thresholding</button>
  <button onclick="edgeAwareAdaptiveThresholdingSobel()">edgeAware Adaptive Thresholding Sobel</button>
  <button onclick="edgeAwareAdaptiveThresholdingColorPreserved()">edgeAware Adaptive Thresholding Color Preserved</button>  
  <button onclick="applyBrightnessAdjustment()">Adjust Brightness</button>
  <button onclick="applyHighPassFilter()">apply High Pass Filter</button>
  <button onclick="applyGaussianBlur()">apply Gaussian Blur</button>
  <button onclick="applyGuidedFilter(8, 0.02);">apply Guided Filter</button>
  <button onclick="applyMedianBlur()">apply Median Blur</button>  
  <button onclick="adaptiveLuminanceSegmentationWithCCL()">Adaptive Luminance Segmentation With CCL</button>
  <button onclick="globalContrastStretching()">Global Contrast Stretching</button>  
  <button onclick="autoTrimWhiteSpace()">auto Trim White Space</button>  
  <button onclick="toneMapReinhardWithExposure()">Tone Mapping Reinhard With Exposure</button>  
  <button onclick="enhanceCanvasImageColorAndSharpen()">Image Enhancement Color And Sharpen</button>
  <button id="invertcolor">Invert Colors</button>
  <button onclick="downscaleImage(canvas, 1024, 1024);">Downscale Image Progressively</button>
  <button onclick="upscaleAndSharpen(canvas, 1024, 1024);">Upscale Image Progressively</button>  
</fieldset>

<!-- IMAGE ANALYSIS & SEGMENTATION -->
<fieldset>
  <legend>üß† Image Analysis & Segmentation</legend>
  <button onclick="applySobelEdgeDetection()">Detect Edges (Sobel Filter)</button>
  <button onclick="segmentImageByLuminance()">Segment Image (Luminance Threshold)</button>
  <button onclick="adaptiveLuminanceSegmentation()">Adaptive Threshold</button>
  <button onclick="adaptiveLuminanceMaskColor()">adaptive Luminance Mask Color</button>
  <button onclick="adaptiveLuminanceMaskWithContours()">adaptive Luminance Mask Color Conters</button>
  <button onclick="segmentImageByOtsu()">Otsu Threshold</button>
  <button onclick="unsharpMasking(1.5, 2);">Unsharp Masking</button>
  <button onclick="contrastStretchingWithHistogramClipping();">Histogram Clipping</button>
  <button onclick="equalizeHSVValueHistogramWithMask();">equalize HSV Histogram</button>
</fieldset>

<!-- IMAGE TO ID CARD / RESIZING -->
<fieldset>
  <legend>üñ®Ô∏è ID Card & Image Resizing</legend>
  <button id="idcardcapture">Capture 3.4in x 2.2in Photo</button>
  <button id="idcardsgenerate">ID Card Generation</button>
  <button id="resizeimage">Resize Image In KB</button>
  <button id="centercontent">Center Content</button>
  <button id="heightresize">Resize Images to 285mm</button>
  <button id="displayblock">Display Block</button>
  <button id="idcard">Resize Images to ID Card</button>
  <button id="idcardstacked">Resize Images to ID Card Stacked Position</button>
  <button id="resizetoA4">Images to A4 Size</button>
</fieldset>

<!-- EMBEDDING & CONVERSIONS -->
<fieldset>
  <legend>üåê Embedding & Conversion</legend>
  <button id="textlayerdisplay">Show or Hide Text Layer</button>
  <button id="embedsvgimages">SVG Embed Images to URL</button>
  <button id="canvastoimage">Canvas to Image</button>
</fieldset>

<!-- PDF TOOLS -->
<fieldset>
  <legend>üìÑ PDF Tools</legend>
  <button id="mergePdfBtn">Merge PDFs</button>
  <button id="downloadFirstPages">Only First Pages of PDF</button>
  <button id="cropPdf">Crop PDF (Top 3.5in, Bottom 2.5in)</button>
  <button id="twopagecrop">Two Page Crop</button>
  <button id="generatePdf">Generate Images to PDF</button>
  <label for="filename" style="display: block;">Name for PDF: <input id="filename" value=""></label>
  <button id="ManualdoublesideWithBlanks">Manual double side With Blanks</button>
  <button id="ManualBookletWithBlanks">Manual Booklet With Blanks</button>
</fieldset>

<!-- PRINT & DOCUMENT OUTPUT -->
<fieldset>
  <legend>üñ®Ô∏è Print & Document Output</legend>
  <button id="noofprint" onclick="generatefidaPDF()">Pending Page Print Slip</button>
  <button id="print">Print Window</button>
  <button id="generatepptx">Download A4 PPTX</button>
  <button onclick='window.location.href="camscanner://scan"'>Open CamScanner</button>
  <button onclick="openWhatsApp()">Chat on WhatsApp</button>

</fieldset>

<!-- CANVAS TOOLS -->
<fieldset>
  <legend>üåÄ Canvas Tools</legend>  
  <label for="rotationSlider">Rotation (degrees): </label>
  <input type="range" id="rotationSlider" min="-45" max="45" value="0">
  <span id="angleValue">0¬∞</span>
  <label for="refno">Enter Reference Number:</label>
<input type="text" id="refno" placeholder="e.g. 20151746013001" />
<a href="#" id="openBillLink" class="btn btn-lg btn-success">Open My Bill</a>        
</fieldset>
  
</div>
  <div><canvas id="canvas"></canvas>
</div>
<div>

  <div id="array">
                    <table>
                      <tbody><tr><td></td><td></td></tr>
                      <tr><td></td><td></td></tr>
                      <tr><td></td><td></td></tr>
                      <tr><td></td><td></td></tr>
                      <tr><td></td><td></td></tr>
                    </tbody></table>
                    </div>

                    <!-- Live camera feed -->
  <div id="video-container" style="display: none;">
    <video id="camera" autoplay muted playsinline></video>
  </div>
</div>

  <script>
    const upload = document.getElementById("upload");
    const imageSelector = document.getElementById("imageSelector");
    const warpBtn = document.getElementById("warpBtn");
    const cropBtn = document.getElementById("cropBtn");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext('2d', { willReadFrequently: true });

    let images = [];
    let currentImageIndex = 0;
    let draggingPoint = null;

    class ImageObject {
      constructor(img) {
        this.img = img;
        this.points = [
          { x: 10, y: 10 },
          { x: img.width - 10, y: 10 },
          { x: img.width - 10, y: img.height - 10 },
          { x: 10, y: img.height - 10 }
        ];
        this.imageData = null;
      }
    }

    let fileListPdf = [];

    upload.addEventListener("change", async (e) => {
  const files = Array.from(e.target.files);
  fileListPdf.push(...files.map(file => ({ file })));

  const loadPromises = files.map(async (file) => {
    if (file.type.startsWith("image/")) {
      return new Promise((resolve) => {
        const img = new Image();
        img.src = URL.createObjectURL(file);
        img.onload = () => resolve([new ImageObject(img, file)]);
      });
    } else if (file.type === "application/pdf") {
      //return processPdf(file, true);
/*
      const pdfBytes = await file.arrayBuffer();
  const pdfDoc = await pdfjsLib.getDocument({ data: pdfBytes }).promise;

  for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
    const page = await pdfDoc.getPage(pageNum);
  }
  await renderPdfWithTextOverlay(pdfBytes, file.name);
  */

      const pdfBytes = await file.arrayBuffer();
      const pdfDoc = await pdfjsLib.getDocument({ data: pdfBytes }).promise;
      const pageImages = [];

      for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
        const page = await pdfDoc.getPage(pageNum);

        const viewport = page.getViewport({ scale: 2 }); // Adjust scale as needed
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        canvas.width = viewport.width;
        canvas.height = viewport.height;

        await page.render({ canvasContext: context, viewport }).promise;

        // Optionally convert canvas to Image
        const img = new Image();
        img.src = canvas.toDataURL("image/png");
        await new Promise((res) => img.onload = res);

        pageImages.push(new ImageObject(img, file));
      }

      return pageImages;

    } else {
      return []; // to avoid undefined entries in results
    }
  });

  // Flatten the array of arrays (because PDFs return arrays)
  const nestedImages = await Promise.all(loadPromises);  
  images = nestedImages.flat();

  currentImageIndex = 0;
  updateImageSelector();
  loadCurrentImage();
  console.log(fileListPdf);
});

    function updateImageSelector() {
      imageSelector.innerHTML = images.map((_, i) =>
        `<option value="${i}">Image ${i + 1}</option>`
      ).join("");
      imageSelector.value = currentImageIndex;
    }

    function loadCurrentImage() {
  const current = images[currentImageIndex];
  canvas.width = current.img.width;
  canvas.height = current.img.height;
  draw(); // Draw the image with the current points on the canvas
}


    function draw() {
  const current = images[currentImageIndex];
  if (!current) {  
  return;
}
  const { img, points } = current;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(img, 0, 0); // Draw the image

  current.imageData = ctx.getImageData(0, 0, canvas.width, canvas.height); // Store image data

  // Calculate font size and circle radius based on the image size
  const fontSize = Math.floor(img.width * 0.025); // 5% of the image's width for the font size
  const circleRadius = Math.floor(img.width * 0.018); // 7% of the image's width for the circle radius

  // Draw points and lines if points are set
  if (pointsDrawn) {
    ctx.strokeStyle = "blue";
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    for (let i = 0; i < points.length; i++) {
      const start = points[i];
      const end = points[(i + 1) % points.length];
      ctx.moveTo(start.x, start.y);
      ctx.lineTo(end.x, end.y);
    }
    ctx.stroke();
    ctx.setLineDash([]);

    // Draw corner handles with transparency
    ctx.fillStyle = "red";
    for (let i = 0; i < points.length; i++) {
      const pt = points[i];

      // Set transparency for circles (alpha value)
      ctx.globalAlpha = 0.7; // 70% opacity for the circle points
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, 6, 0, Math.PI * 2);
      ctx.fill();

      // Draw the larger circle in white with transparency
      ctx.fillStyle = "white";
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, circleRadius, 0, Math.PI * 2); // Larger circle to hold the number
      ctx.fill();

      // Reset the alpha value for the text
      ctx.globalAlpha = 1.0;

      // Set the font size and draw the number in black
      ctx.fillStyle = "black";
      ctx.font = `${fontSize}px Arial`; // Set font size dynamically based on image width
      ctx.textAlign = "center"; // Center the text horizontally
      ctx.textBaseline = "middle"; // Center the text vertically
      ctx.fillText(i + 1, pt.x, pt.y); // Position the number in the circle
    }
  }
  //drawGuides();
}
/*
    canvas.addEventListener("mousedown", (e) => {
      const current = images[currentImageIndex];
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      for (let pt of current.points) {
        const dx = pt.x - x;
        const dy = pt.y - y;
        if (dx * dx + dy * dy < 100) {
          draggingPoint = pt;
          return;
        }
      }

      for (let i = 0; i < current.points.length; i++) {
        const a = current.points[i];
        const b = current.points[(i + 1) % current.points.length];
        if (pointNearLine(x, y, a, b, 6)) {
          draggingPoint = { line: [a, b], dx: x, dy: y };
          return;
        }
      }
    });

    canvas.addEventListener("mousemove", (e) => {
      if (!draggingPoint) return;
      const current = images[currentImageIndex];
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      if (draggingPoint.line) {
        const [a, b] = draggingPoint.line;
        const dx = x - draggingPoint.dx;
        const dy = y - draggingPoint.dy;
        a.x += dx; a.y += dy;
        b.x += dx; b.y += dy;
        draggingPoint.dx = x;
        draggingPoint.dy = y;
      } else {
        draggingPoint.x = x;
        draggingPoint.y = y;
      }

      draw();
    });

    canvas.addEventListener("mouseup", () => {
      draggingPoint = null;
    });
    */

    let pointsDrawn = true; // Flag to control if points and lines should be drawn

warpBtn.addEventListener("click", () => {
  applyPerspectiveWarp();
  pointsDrawn = false;  // Disable drawing points/lines after the warp

  const canvas = document.querySelector("canvas");
const dataURL = canvas.toDataURL(); // Get canvas image as data URL
/*
const tds = document.querySelectorAll("td");

for (let td of tds) {
  if (!td.querySelector("img")) {
    const img = document.createElement("img");
    img.src = dataURL;
    td.appendChild(img);
    break; // Stop after the first match
  }
}
  */
});


    imageSelector.addEventListener("change", (e) => {
      // pointsDrawn = true;  // Enable drawing points/lines after switching images
  currentImageIndex = parseInt(e.target.value);
  loadCurrentImage();
});

    function applyPerspectiveWarp() {
  const current = images[currentImageIndex];
  const [tl, tr, br, bl] = current.points;
  const width = Math.floor(Math.max(distance(tl, tr), distance(bl, br)));
  const height = Math.floor(Math.max(distance(tl, bl), distance(tr, br)));

  const destCanvas = document.createElement("canvas");
  destCanvas.width = width;
  destCanvas.height = height;
  const destCtx = destCanvas.getContext("2d");
  const destImageData = destCtx.createImageData(width, height);

  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const srcPt = bilinearInterpolate(x / width, y / height, tl, tr, br, bl);
      const sx = Math.floor(srcPt.x);
      const sy = Math.floor(srcPt.y);

      if (sx < 0 || sy < 0 || sx >= canvas.width || sy >= canvas.height) continue;

      const srcIdx = (sy * canvas.width + sx) * 4;
      const destIdx = (y * width + x) * 4;

      for (let i = 0; i < 4; i++) {
        destImageData.data[destIdx + i] = current.imageData.data[srcIdx + i];
      }
    }
  }

  // Replace image with warped version
  const newImg = new Image();
  destCtx.putImageData(destImageData, 0, 0);
  newImg.src = destCanvas.toDataURL();
  newImg.onload = () => {
    images[currentImageIndex] = new ImageObject(newImg);
    loadCurrentImage();
  };
/*
  const tds = document.querySelectorAll("td");

for (let td of tds) {
  if (!td.querySelector("img")) {
    const img = document.createElement("img");
    img.src = destCanvas.toDataURL();
    td.appendChild(img);
    break; // Stop after the first match
  }
}
  */
}


    function bilinearInterpolate(u, v, tl, tr, br, bl) {
      const topX = tl.x + u * (tr.x - tl.x);
      const topY = tl.y + u * (tr.y - tl.y);
      const bottomX = bl.x + u * (br.x - bl.x);
      const bottomY = bl.y + u * (br.y - bl.y);
      const x = topX + v * (bottomX - topX);
      const y = topY + v * (bottomY - topY);
      return { x, y };
    }

    function distance(p1, p2) {
      return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
    }

    function pointNearLine(px, py, a, b, threshold) {
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const lenSq = dx * dx + dy * dy;
      const t = ((px - a.x) * dx + (py - a.y) * dy) / lenSq;
      if (t < 0 || t > 1) return false;
      const projX = a.x + t * dx;
      const projY = a.y + t * dy;
      const distSq = (projX - px) ** 2 + (projY - py) ** 2;
      return distSq < threshold * threshold;
    }

// Handle drag and drop event
async function dropHandler(event) {
  event.preventDefault();

  if (event.dataTransfer.items) {
    for (let i = 0; i < event.dataTransfer.items.length; i++) {
      if (event.dataTransfer.items[i].kind === 'file') {
        const file = event.dataTransfer.items[i].getAsFile();
        if (file.type.startsWith('image/')) {
          await processFile(file); // process image
        } else if (file.type === 'application/pdf') {
          await processPdf(file); // process PDF pages
        }
      }
    }
  }
}

// Process image file dropped or pasted
function processFile(file) {
  return new Promise((resolve) => {
    const img = new Image();
    img.src = URL.createObjectURL(file);
    img.onload = () => {
      images.push(new ImageObject(img, file));
      currentImageIndex = images.length - 1;
      updateImageSelector();
      loadCurrentImage();
      resolve();
    };
  });
}

async function processPdf(file, useTextOverlay = false) {
  fileListPdf.push({ file });

  const pdfBytes = await file.arrayBuffer();
  const pdfDoc = await pdfjsLib.getDocument({ data: pdfBytes }).promise;

  for (let pageNum = 1; pageNum <= pdfDoc.numPages; pageNum++) {
    const page = await pdfDoc.getPage(pageNum);

    if (useTextOverlay) {
    await renderPdfWithTextOverlay(pdfBytes, file.name);
    return
    }    
  }
}

async function renderPdfWithTextOverlay(pdfData, fileName = '') {
      const loadingTask = pdfjsLib.getDocument({
        data: pdfData,
        fontExtraProperties: true,
        cMapUrl: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/cmaps/',
        cMapPacked: true,
        standardFontDataUrl: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/standard_fonts/'
      });

      const pdf = await loadingTask.promise;
      // Check if the container already exists
let container = document.getElementById('svg-container');

if (!container) {
  // Create the container dynamically if it doesn't exist
  container = document.createElement('div');
  container.id = 'svg-container';
  document.body.appendChild(container); // or another parent element
}

      const title = document.createElement('h2');
      title.textContent = fileName || 'Untitled PDF';
      container.appendChild(title);

      for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
        const page = await pdf.getPage(pageNum);
        const viewport = page.getViewport({ scale: 2 });
        const opList = await page.getOperatorList();
        const svgGfx = new pdfjsLib.SVGGraphics(page.commonObjs, page.objs);
        svgGfx.embedFonts = true;

        const pageWrapper = document.createElement('div');
        pageWrapper.style.position = 'relative';
        pageWrapper.style.width = `${viewport.width}px`;
        pageWrapper.style.height = `${viewport.height}px`;
        pageWrapper.style.marginBottom = '40px';

        try {
          const svg = await svgGfx.getSVG(opList, viewport);
          svg.style.position = 'absolute';
          pageWrapper.appendChild(svg);

          // Save for zip download
          renderedSVGs.push({
            svgElement: svg,
            fileName: `${fileName.replace(/\.pdf$/i, '')}_page${pageNum}.svg`
          });

        } catch (err) {
          console.warn(`Page ${pageNum} SVG render failed:`, err);          
          //pageWrapper.appendChild(canvas);
        }

        // Text layer
        const textContent = await page.getTextContent();
        const textLayerDiv = document.createElement('div');
        textLayerDiv.className = 'text-layer';
        textLayerDiv.style.width = `${viewport.width}px`;
        textLayerDiv.style.height = `${viewport.height}px`;
        textLayerDiv.style.position = 'relative';
        textLayerDiv.style.marginTop = '10px';

        for (const item of textContent.items) {
          const transform = pdfjsLib.Util.transform(viewport.transform, item.transform);
          const x = transform[4];
          const y = transform[5];
          const fontSize = Math.hypot(transform[2], transform[3]);

          const span = document.createElement('span');
          span.textContent = item.str;
          span.style.left = `${x}px`;
          span.style.top = `${y - fontSize}px`;
          span.style.fontSize = `${fontSize}px`;
          span.style.fontFamily = item.fontName || 'sans-serif';

          textLayerDiv.appendChild(span);
        }

        pageWrapper.appendChild(textLayerDiv);

        const label = document.createElement('h4');
        label.textContent = `Page ${pageNum}`;
        container.appendChild(label);
        container.appendChild(pageWrapper);
      }
    }


document.addEventListener('paste', async (e) => {
  const items = (e.clipboardData || e.originalEvent.clipboardData).items;

  const promises = [];

  for (let i = 0; i < items.length; i++) {
    if (items[i].kind === 'file') {
      const file = items[i].getAsFile();
      if (file.type.startsWith('image/')) {
        promises.push(processFile(file));
      } else if (file.type === 'application/pdf') {
        promises.push(processPdf(file, useTextOverlay = true));
      }
    }
  }

  try {
    await Promise.all(promises);
    console.log('All files processed');
  } catch (error) {
    console.error('Error processing files:', error);
  }
  console.log(fileListPdf);
}, false);


// Attach drop and dragover event listeners
document.body.ondragover = (e) => e.preventDefault(); // Allow drop event
document.body.ondrop = dropHandler;


  document.querySelector("#rotate").addEventListener("click", () => {
const current1 = images[currentImageIndex];
  current1.points = [];  // Clear points
  pointsDrawn = false;  // Disable drawing points/lines
  draw();  // Redraw canvas without points

  const current = images[currentImageIndex];
  const oldCanvas = document.createElement("canvas");
  oldCanvas.width = canvas.width;
  oldCanvas.height = canvas.height;
  oldCanvas.getContext("2d").drawImage(canvas, 0, 0);

  // Rotate canvas
  canvas.width = oldCanvas.height;
  canvas.height = oldCanvas.width;

  // Rotate image visually
  ctx.save();
  ctx.translate(canvas.width, 0);
  ctx.rotate(Math.PI / 2);
  ctx.drawImage(oldCanvas, 0, 0);
  ctx.restore();

  // Rotate points (90¬∞ clockwise)
  const rotatedPoints = current.points.map(pt => ({
    x: pt.y,
    y: canvas.width - pt.x
  }));

  // Create new image object with rotated image and updated points
  const newImg = new Image();
  newImg.src = canvas.toDataURL();
  newImg.onload = () => {
    images[currentImageIndex] = new ImageObject(newImg);
    // pointsDrawn = true;  // Don‚Äôt auto-show the points
    loadCurrentImage();
  };
});

const removePointsBtn = document.getElementById("removePointsBtn");

let pointsVisible = true; // Initially assume points are visible

// Toggle points visibility on button click
removePointsBtn.addEventListener("click", () => {
  const current = images[currentImageIndex];

  if (pointsVisible) {
    current.hiddenPoints = current.points; // Temporarily store current points
    current.points = []; // Clear points
    pointsDrawn = false;
    removePointsBtn.textContent = "Show Points"; // Update button label
  } else {
    current.points = current.hiddenPoints || []; // Restore points
    pointsDrawn = true;
    removePointsBtn.textContent = "Remove Points"; // Update button label
  }

  pointsVisible = !pointsVisible; // Toggle the state
  draw(); // Redraw the canvas
});


function drawSelectionRectangle() {
  if (!rectStart || !rectEnd) return;
  ctx.save();
  ctx.strokeStyle = 'rgba(0, 0, 255, 0.6)';
  ctx.lineWidth = 2;
  ctx.setLineDash([4, 2]);
  ctx.strokeRect(
    Math.min(rectStart.x, rectEnd.x),
    Math.min(rectStart.y, rectEnd.y),
    Math.abs(rectStart.x - rectEnd.x),
    Math.abs(rectStart.y - rectEnd.y)
  );
  ctx.restore();
}

let drawingRectangle = false;
let rectStart = null;
let rectEnd = null;
let lockAspectRatio = false;
let mousePosition = null;

canvas.addEventListener("mouseleave", () => {
  mousePosition = null;
  draw(); // Redraw without guides
});

canvas.addEventListener("mousedown", (e) => {
  const current = images[currentImageIndex];
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  draggingPoint = null;

  for (let pt of current.points) {
    const dx = pt.x - x;
    const dy = pt.y - y;
    if (dx * dx + dy * dy < 100) {
      draggingPoint = pt;
      return;
    }
  }

  for (let i = 0; i < current.points.length; i++) {
    const a = current.points[i];
    const b = current.points[(i + 1) % current.points.length];
    if (pointNearLine(x, y, a, b, 6)) {
      draggingPoint = { line: [a, b], dx: x, dy: y };
      return;
    }
  }

  // Shift + optional Ctrl for aspect ratio
  if (e.shiftKey) {
    rectStart = { x, y };
    rectEnd = { x, y };
    drawingRectangle = true;
    lockAspectRatio = e.ctrlKey; // true if Ctrl + Shift held
  }  
});

canvas.addEventListener("dblclick", (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
    rectStart = { x, y };
    rectEnd = { x, y };
    drawingRectangle = true;
    lockAspectRatio = e.ctrlKey; // true if Ctrl + Shift held  
});


canvas.addEventListener("mousemove", (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  mousePosition = { x, y }; // Store current mouse position

  // Your existing dragging code...
  if (draggingPoint) {
    const current = images[currentImageIndex];
    if (draggingPoint.line) {
      const [a, b] = draggingPoint.line;
      const dx = x - draggingPoint.dx;
      const dy = y - draggingPoint.dy;
      a.x += dx; a.y += dy;
      b.x += dx; b.y += dy;
      draggingPoint.dx = x;
      draggingPoint.dy = y;
    } else {
      draggingPoint.x = x;
      draggingPoint.y = y;
    }
    draw();
  }

  if (drawingRectangle) {
    let x2 = x;
    let y2 = y;

    if (lockAspectRatio) {
      const ratio = 35 / 45;
      const dx = x - rectStart.x;
      const dy = y - rectStart.y;
      if (Math.abs(dx) > Math.abs(dy)) {
        x2 = rectStart.x + dx;
        y2 = rectStart.y + (Math.sign(dx) * Math.abs(dx)) / ratio;
      } else {
        y2 = rectStart.y + dy;
        x2 = rectStart.x + (Math.sign(dy) * Math.abs(dy)) * ratio;
      }
    }

    rectEnd = { x: x2, y: y2 };
  }

  draw();
  drawSelectionRectangle();
  //drawGuides(); // Draw crosshair guides
  // Shift + optional Ctrl for aspect ratio
  if (e.shiftKey) {
    drawGuides();
  }
});

canvas.addEventListener("mouseup", () => {
  if (drawingRectangle && rectStart && rectEnd) {
    const current = images[currentImageIndex];

    // Define corners in clockwise order: TL, TR, BR, BL
    const x1 = rectStart.x;
    const y1 = rectStart.y;
    const x2 = rectEnd.x;
    const y2 = rectEnd.y;

    current.points = [
      { x: Math.min(x1, x2), y: Math.min(y1, y2) },
      { x: Math.max(x1, x2), y: Math.min(y1, y2) },
      { x: Math.max(x1, x2), y: Math.max(y1, y2) },
      { x: Math.min(x1, x2), y: Math.max(y1, y2) }
    ];

    pointsDrawn = true;
    rectStart = rectEnd = null;
  drawingRectangle = false;
  lockAspectRatio = false;
  draw();
  }

  draggingPoint = null;
});

function drawGuides() {
  if (!mousePosition) return;

  ctx.save();
  ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
  ctx.lineWidth = 2;
  ctx.setLineDash([5, 5]);

  ctx.beginPath();
  ctx.moveTo(mousePosition.x, 0);
  ctx.lineTo(mousePosition.x, canvas.height);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(0, mousePosition.y);
  ctx.lineTo(canvas.width, mousePosition.y);
  ctx.stroke();

  ctx.restore();
}

function sharpenImage() {
            const canvas = document.querySelector("canvas");
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;

            // Sharpening kernel
            const kernel = [
                0, -1, 0,
                -1, 5, -1,
                0, -1, 0
            ];

            const newData = new Uint8ClampedArray(data.length);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let r = 0, g = 0, b = 0;

                    // Apply the kernel
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const pixelX = x + kx;
                            const pixelY = y + ky;
                            const pixelIndex = ((pixelY * width) + pixelX) * 4;

                            if (pixelX >= 0 && pixelX < width && pixelY >= 0 && pixelY < height) {
                                const kernelValue = kernel[(ky + 1) * 3 + (kx + 1)];
                                r += data[pixelIndex] * kernelValue;
                                g += data[pixelIndex + 1] * kernelValue;
                                b += data[pixelIndex + 2] * kernelValue;
                            }
                        }
                    }

                    const newPixelIndex = (y * width + x) * 4;
                    newData[newPixelIndex] = Math.min(255, Math.max(0, r));     // Red
                    newData[newPixelIndex + 1] = Math.min(255, Math.max(0, g)); // Green
                    newData[newPixelIndex + 2] = Math.min(255, Math.max(0, b)); // Blue
                    newData[newPixelIndex + 3] = data[newPixelIndex + 3];       // Alpha
                }
            }

            // Update the canvas with the new image data
            const newImageData = new ImageData(newData, width, height);
            ctx.putImageData(newImageData, 0, 0);
            window.image = newImageData;
        }

const sharpen = (ctx, w, h, mix) => {
    var x, sx, sy, r, g, b, a, dstOff, srcOff, wt, cx, cy, scy, scx,
      weights = [0, -1, 0, -1, 5, -1, 0, -1, 0],
      katet = Math.round(Math.sqrt(weights.length)),
      half = (katet * 0.5) | 0,
      dstData = ctx.createImageData(w, h),
      dstBuff = dstData.data,
      srcBuff = ctx.getImageData(0, 0, w, h).data,
      y = h;
    while (y--) {
      x = w;
      while (x--) {
        sy = y;
        sx = x;
        dstOff = (y * w + x) * 4;
        r = 0;
        g = 0;
        b = 0;
        a = 0;
        if(x>0 && y>0 && x<w-1 && y<h-1) {
          for (cy = 0; cy < katet; cy++) {
            for (cx = 0; cx < katet; cx++) {
              scy = sy + cy - half;
              scx = sx + cx - half;
  
              if (scy >= 0 && scy < h && scx >= 0 && scx < w) {
                srcOff = (scy * w + scx) * 4;
                wt = weights[cy * katet + cx];
  
                r += srcBuff[srcOff] * wt;
                g += srcBuff[srcOff + 1] * wt;
                b += srcBuff[srcOff + 2] * wt;
                a += srcBuff[srcOff + 3] * wt;
              }
            }
          }
  
          dstBuff[dstOff] = r * mix + srcBuff[dstOff] * (1 - mix);
          dstBuff[dstOff + 1] = g * mix + srcBuff[dstOff + 1] * (1 - mix);
          dstBuff[dstOff + 2] = b * mix + srcBuff[dstOff + 2] * (1 - mix);
          dstBuff[dstOff + 3] = srcBuff[dstOff + 3];
        } else {
          dstBuff[dstOff] = srcBuff[dstOff];
          dstBuff[dstOff + 1] = srcBuff[dstOff + 1];
          dstBuff[dstOff + 2] = srcBuff[dstOff + 2];
          dstBuff[dstOff + 3] = srcBuff[dstOff + 3];
        }
      }
    }
  
      ctx.putImageData(dstData, 0, 0);
  }

  /*
  document.querySelector('#sharpenImage').addEventListener("click", function(){
  sharpenImage();  
})
  */

document.querySelector('#sharpenImage').addEventListener("click", function() {
    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    sharpen(ctx, canvas.width, canvas.height, 1.0);  // Full sharpening (mix = 1.0)
});

document.querySelector('#print').addEventListener("click", function() {
    window.print();
});

document.querySelector('#idcard').addEventListener("click", async function() {
  await generatePortraitPDF();

    document.querySelectorAll("img").forEach(function(e){
      e.style.width = "3.4in";
      e.style.height = "2.2in";
    });
    document.querySelector("table").style.margin = "0 auto";
    document.querySelector("table").style.borderSpacing = "45px 15px";
    document.querySelector("table").style.pageBreakAfter = "always";

    // Ask the user
  const printType = confirm("Click OK for double-sided printing, or Cancel for single-sided printing.");

if (printType) {
  // Clone the table node
  const clonedNode = document.querySelector('#array table').cloneNode(true);

  // Set padding style
  clonedNode.style.paddingTop = '0.1in';

  // Append the cloned node
  document.querySelector("#array").appendChild(clonedNode);
  window.print();
} else{
  window.print();
  window.print();
}

});

document.querySelector('#idcardstacked').addEventListener("click", function() {

  const table = document.querySelector("table");
  table.parentElement.parentElement.style.margin = "0 auto";
  table.style.borderSpacing = "20px";

  // Resize all images
  document.querySelectorAll("img").forEach(function(e){
    e.style.width = "3.4in";
    e.style.height = "2.2in";
  });

  document.querySelectorAll("#array img").forEach((img, index) => {
  document.querySelectorAll("#array td:nth-child(1)")[index].appendChild(img);  
});

document.querySelectorAll("#array td:nth-child(2)").forEach(function(e){
  e.remove();  
})

});


document.querySelector('#resizeimage').addEventListener("click", function(){
  const originalCanvas = document.querySelector('canvas');
const targetSizeKB = parseFloat(prompt("Enter target size in KB:")-0.2);

function resizeCanvas(canvas, scale) {
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = canvas.width * scale;
  tempCanvas.height = canvas.height * scale;
  const ctx = tempCanvas.getContext('2d');
  ctx.drawImage(canvas, 0, 0, tempCanvas.width, tempCanvas.height);
  return tempCanvas;
}

function getJPEGBlob(canvas, quality, callback) {
  canvas.toBlob((blob) => {
    callback(blob);
  }, 'image/jpeg', quality);
}

function findBestJPEGQuality(canvas, targetKB, callback) {
  let low = 0.1;
  let high = 1.0;
  let iterations = 10;

  function step(i) {
    if (i >= iterations) {
      getJPEGBlob(canvas, (low + high) / 2, callback);
      return;
    }

    let mid = (low + high) / 2;
    getJPEGBlob(canvas, mid, (blob) => {
      const sizeKB = blob.size / 1024;
      console.log("Quality " + mid.toFixed(2) + " ‚Üí " + sizeKB.toFixed(2) + "KB");
      if (sizeKB > targetKB) {
        high = mid;
      } else {
        low = mid;
      }
      step(i + 1);
    });
  }

  step(0);
}

// Slightly resize canvas (e.g., 90%)
const resizedCanvas = resizeCanvas(originalCanvas, 0.9);

// Then compress to JPEG to reach target file size
findBestJPEGQuality(resizedCanvas, targetSizeKB, (blob) => {
  const finalSizeKB = (blob.size / 1024).toFixed(2);
  console.log("‚úÖ Final size: " + finalSizeKB + " KB");

  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = 'optimized_canvas_image.jpg';
  link.click();
});

})

// Utility to get touch coordinates
function getTouchPos(touch, canvas) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: touch.clientX - rect.left,
    y: touch.clientY - rect.top
  };
}

canvas.addEventListener("touchstart", (e) => {
  if (e.touches.length > 1) return; // Ignore multi-touch
  const touch = e.touches[0];
  const pos = getTouchPos(touch, canvas);

  const current = images[currentImageIndex];
  draggingPoint = null;

  for (let pt of current.points) {
    const dx = pt.x - pos.x;
    const dy = pt.y - pos.y;
    if (dx * dx + dy * dy < 100) {
      draggingPoint = pt;
      return;
    }
  }

  for (let i = 0; i < current.points.length; i++) {
    const a = current.points[i];
    const b = current.points[(i + 1) % current.points.length];
    if (pointNearLine(pos.x, pos.y, a, b, 6)) {
      draggingPoint = { line: [a, b], dx: pos.x, dy: pos.y };
      return;
    }
  }

  // Start rectangle selection if user taps while holding shiftKey (won't work on mobile)
  rectStart = pos;
  rectEnd = pos;
  drawingRectangle = true;

  e.preventDefault();
}, { passive: false });

canvas.addEventListener("touchmove", (e) => {
  if (e.touches.length > 1) return;
  const touch = e.touches[0];
  const pos = getTouchPos(touch, canvas);

  if (draggingPoint) {
    const current = images[currentImageIndex];
    if (draggingPoint.line) {
      const [a, b] = draggingPoint.line;
      const dx = pos.x - draggingPoint.dx;
      const dy = pos.y - draggingPoint.dy;
      a.x += dx;
      a.y += dy;
      b.x += dx;
      b.y += dy;
      draggingPoint.dx = pos.x;
      draggingPoint.dy = pos.y;
    } else {
      draggingPoint.x = pos.x;
      draggingPoint.y = pos.y;
    }
    draw();
  }

  if (drawingRectangle) {
    rectEnd = pos;
    draw();
    drawSelectionRectangle();
  }

  e.preventDefault();
}, { passive: false });

canvas.addEventListener("touchend", () => {
  if (drawingRectangle && rectStart && rectEnd) {
    const current = images[currentImageIndex];
    const x1 = rectStart.x;
    const y1 = rectStart.y;
    const x2 = rectEnd.x;
    const y2 = rectEnd.y;

    current.points = [
      { x: Math.min(x1, x2), y: Math.min(y1, y2) },
      { x: Math.max(x1, x2), y: Math.min(y1, y2) },
      { x: Math.max(x1, x2), y: Math.max(y1, y2) },
      { x: Math.min(x1, x2), y: Math.max(y1, y2) }
    ];

    pointsDrawn = true;
    rectStart = rectEnd = null;
    drawingRectangle = false;
    draw();
  }

  draggingPoint = null;
});

function applyContrastStretching(brighten = false) {
  const canvas1 = document.getElementById("canvas");
  const ctx1 = canvas1.getContext("2d");

  const originalImage = ctx1.getImageData(0, 0, canvas1.width, canvas1.height);

  const imgData = new ImageData(
    new Uint8ClampedArray(originalImage.data),
    originalImage.width,
    originalImage.height
  );
  const data = imgData.data;

  // Find min and max for each color channel separately
  let minR = 255, maxR = 0;
  let minG = 255, maxG = 0;
  let minB = 255, maxB = 0;

  for (let i = 0; i < data.length; i += 4) {
    if (data[i] < minR) minR = data[i];
    if (data[i] > maxR) maxR = data[i];
    if (data[i + 1] < minG) minG = data[i + 1];
    if (data[i + 1] > maxG) maxG = data[i + 1];
    if (data[i + 2] < minB) minB = data[i + 2];
    if (data[i + 2] > maxB) maxB = data[i + 2];
  }

  // Stretch contrast and optionally brighten for each channel
  for (let i = 0; i < data.length; i += 4) {
    // Stretch R
    let stretchedR = ((data[i] - minR) / (maxR - minR)) * 255;
    // Stretch G
    let stretchedG = ((data[i + 1] - minG) / (maxG - minG)) * 255;
    // Stretch B
    let stretchedB = ((data[i + 2] - minB) / (maxB - minB)) * 255;

    if (brighten) {
      stretchedR = Math.min(stretchedR * 1.2, 255);
      stretchedG = Math.min(stretchedG * 1.2, 255);
      stretchedB = Math.min(stretchedB * 1.2, 255);
    }

    data[i] = stretchedR;
    data[i + 1] = stretchedG;
    data[i + 2] = stretchedB;
  }

  // Create mask for text pixels using luminance (for mask only)
  const width = imgData.width;
  const height = imgData.height;
  const mask = new Uint8Array(width * height);

  // Use luminance for text detection: 0.299 R + 0.587 G + 0.114 B
  // Also check local contrast (3x3 neighborhood) on luminance

  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = (y * width + x) * 4;
      const R = data[idx];
      const G = data[idx + 1];
      const B = data[idx + 2];

      const luminance = 0.299 * R + 0.587 * G + 0.114 * B;

      // Local min/max luminance for contrast
      let localMin = 255, localMax = 0;
      for (let ny = Math.max(0, y - 1); ny <= Math.min(height - 1, y + 1); ny++) {
        for (let nx = Math.max(0, x - 1); nx <= Math.min(width - 1, x + 1); nx++) {
          const nidx = (ny * width + nx) * 4;
          const nR = data[nidx];
          const nG = data[nidx + 1];
          const nB = data[nidx + 2];
          const nLum = 0.299 * nR + 0.587 * nG + 0.114 * nB;
          if (nLum < localMin) localMin = nLum;
          if (nLum > localMax) localMax = nLum;
        }
      }

      const localContrast = localMax - localMin;

      // Thresholds for text pixels
      mask[y * width + x] = (luminance < 40 && localContrast > 30) ? 1 : 0;
    }
  }

  // Darken text pixels by scaling down their RGB values (preserve color)
  for (let i = 0; i < data.length; i += 4) {
    const maskValue = mask[i / 4];
    if (maskValue) {
      data[i] = data[i] * 0.5;
      data[i + 1] = data[i + 1] * 0.5;
      data[i + 2] = data[i + 2] * 0.5;
    }
  }

  // Sharpen kernel
  const sharpenKernel = [
    -1, -1, -1,
    -1,  9, -1,
    -1, -1, -1
  ];

  // Apply selective sharpening twice on masked text pixels
  convolveSelective(imgData, sharpenKernel, 3, mask);
  convolveSelective(imgData, sharpenKernel, 3, mask);

  ctx1.putImageData(imgData, 0, 0);
}


// Selective convolution (unchanged)
function convolveSelective(imageData, kernel, kernelSize, mask) {
  const side = kernelSize;
  const halfSide = Math.floor(side / 2);

  const src = imageData.data;
  const sw = imageData.width;
  const sh = imageData.height;

  const output = new Uint8ClampedArray(src.length);

  for (let y = 0; y < sh; y++) {
    for (let x = 0; x < sw; x++) {
      const idx = y * sw + x;

      if (mask[idx]) {
        let r = 0, g = 0, b = 0;

        for (let ky = 0; ky < side; ky++) {
          for (let kx = 0; kx < side; kx++) {
            const posX = x + kx - halfSide;
            const posY = y + ky - halfSide;

            if (posX >= 0 && posX < sw && posY >= 0 && posY < sh) {
              const offset = (posY * sw + posX) * 4;
              const weight = kernel[ky * side + kx];

              r += src[offset] * weight;
              g += src[offset + 1] * weight;
              b += src[offset + 2] * weight;
            }
          }
        }

        const dstOffset = idx * 4;
        output[dstOffset] = Math.min(Math.max(r, 0), 255);
        output[dstOffset + 1] = Math.min(Math.max(g, 0), 255);
        output[dstOffset + 2] = Math.min(Math.max(b, 0), 255);
        output[dstOffset + 3] = src[dstOffset + 3];
      } else {
        // Copy original pixel for non-text pixels
        const srcOffset = idx * 4;
        output[srcOffset] = src[srcOffset];
        output[srcOffset + 1] = src[srcOffset + 1];
        output[srcOffset + 2] = src[srcOffset + 2];
        output[srcOffset + 3] = src[srcOffset + 3];
      }
    }
  }

  // Copy output back to imageData
  for (let i = 0; i < src.length; i++) {
    src[i] = output[i];
  }
}

document.querySelector("#canvastoimage").addEventListener("click", function(e){
  pointsDrawn = false;
  //draw();

      const tds = document.querySelectorAll("td");

for (let td of tds) {
  if (!td.querySelector("img")) {
    const img = document.createElement("img");
    img.src = document.querySelector("canvas").toDataURL();

/*
    const originalCanvas = document.querySelector("canvas");
    const base64Length = originalCanvas.toDataURL().length;
const maxBase64Length = 500000; // ~500 KB

if (base64Length > maxBase64Length) {

// Set scale factor (e.g., 0.5 for half size)
const scale = 0.5;
const scaledCanvas = document.createElement("canvas");
scaledCanvas.width = originalCanvas.width * scale;
scaledCanvas.height = originalCanvas.height * scale;

const ctx = scaledCanvas.getContext("2d");
// Use high quality scaling
ctx.imageSmoothingEnabled = true;
ctx.imageSmoothingQuality = 'high';

// Draw scaled version of original canvas
ctx.drawImage(originalCanvas, 0, 0, scaledCanvas.width, scaledCanvas.height);

// Use the scaled canvas for the image src
img.src = scaledCanvas.toDataURL();
}
*/

    td.appendChild(img);
    break; // Stop after the first match
  }
}


const imgs = document.querySelectorAll('#array table td img');

imgs.forEach(img => {
  const wrapper = img.parentNode; // Use <td> as the wrapper
  wrapper.style.position = 'relative'; // Ensure relative positioning

  // Only add the delete button if it doesn't already exist
  if (!wrapper.querySelector('.delete-btn')) {
    // Create delete button
    const delBtn = document.createElement('button');
    delBtn.textContent = '√ó';
    delBtn.className = 'delete-btn'; // Assign a class for easy checking
    Object.assign(delBtn.style, {
      position: 'absolute',
      top: '2px',
      left: '2px',
      width: '22px',
      height: '22px',
      backgroundColor: 'rgba(255, 0, 0, 0.85)',
      border: 'none',
      borderRadius: '50%',
      color: 'white',
      fontWeight: 'bold',
      fontSize: '16px',
      cursor: 'pointer',
      display: 'none',
      padding: '0',
      lineHeight: '22px',
      textAlign: 'center',
      userSelect: 'none',
      zIndex: '10',
    });
    wrapper.appendChild(delBtn);

    // Show delete button on hover
    wrapper.addEventListener('mouseenter', () => {
      delBtn.style.display = 'block';
    });
    wrapper.addEventListener('mouseleave', () => {
      delBtn.style.display = 'none';
    });

    // Delete image on click
    delBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      img.remove(); // Just remove the image, keep the <td>
      delBtn.remove(); // Optionally remove the button itself too
    });
  }

  // Make img draggable
  img.setAttribute('draggable', true);

  img.addEventListener('dragstart', (e) => {
    e.dataTransfer.setData('text/plain', e.target.src);
    e.dataTransfer.effectAllowed = 'move';
    e.target.classList.add('dragging');
  });

  img.addEventListener('dragend', (e) => {
    e.target.classList.remove('dragging');
  });

  // Allow dropping on the image
  img.addEventListener('dragover', (e) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
  });

  img.addEventListener('drop', (e) => {
    e.preventDefault();
    const draggedSrc = e.dataTransfer.getData('text/plain');
    const target = e.target;
    const draggedImg = [...document.querySelectorAll('#array table td img')].find(i => i.src === draggedSrc);

    if (draggedImg && draggedImg !== target) {
      // Swap the src attributes of the dragged and target images
      const tempSrc = target.src;
      target.src = draggedImg.src;
      draggedImg.src = tempSrc;
    }
  });
});
})

document.getElementById('generatePdf').addEventListener('click', async () => {
  const fileList = [];

  // Try to collect <img> elements first
  const domImages = document.querySelectorAll('img');
  domImages.forEach(img => {
    if (img.src) {
      fileList.push({ type: 'imageElement', element: img });
    }
  });

  // If no <img> in DOM, fallback to images[] array
  if (fileList.length === 0 && typeof images !== 'undefined' && images.length > 0) {
    images.forEach(imageObj => {
      fileList.push({ type: 'imageElement', element: imageObj.img });
    });
  }

  const pdfDoc = await PDFLib.PDFDocument.create();

  const processImageElement = async (imgElement) => {
    try {
      const imgData = imgElement.src;

      let image;
      if (imgData.startsWith('data:image/png')) {
        image = await pdfDoc.embedPng(imgData);
      } else if (imgData.startsWith('data:image/jpeg') || imgData.startsWith('data:image/jpg')) {
        image = await pdfDoc.embedJpg(imgData);
      } else {
        const blob = await fetch(imgData).then(r => r.blob());
        const dataUrl = await new Promise((resolve) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.readAsDataURL(blob);
        });

        if (blob.type === 'image/png') {
          image = await pdfDoc.embedPng(dataUrl);
        } else if (blob.type === 'image/jpeg') {
          image = await pdfDoc.embedJpg(dataUrl);
        } else {
          throw new Error('Unsupported image type');
        }
      }

      const { width, height } = image.scale(2);
      const page = pdfDoc.addPage([width, height]);
      page.drawImage(image, { x: 0, y: 0, width, height });
    } catch (err) {
      console.error("Failed to embed image:", err);
    }
  };

  // Process all collected image elements
  for (const fileObj of fileList) {
    if (fileObj.type === 'imageElement') {
      await processImageElement(fileObj.element);
    }
  }

  const pdfBytes = await pdfDoc.save();

  const pdfName = document.querySelector("#filename").value;

  const createFileName = () => {
    const today = new Date();
    const pad = (n) => n.toString().padStart(2, '0');
    const day = pad(today.getDate());
    const month = pad(today.getMonth() + 1);
    const year = today.getFullYear();
    const hours = pad(today.getHours());
    const minutes = pad(today.getMinutes());
    const seconds = pad(today.getSeconds());
    return `PDF ${day}-${month}-${year} ${hours}-${minutes}-${seconds}.pdf`;
  };

  const fileName = pdfName
    ? (pdfName.endsWith('.pdf') ? pdfName : `${pdfName}.pdf`)
    : createFileName();

  const blob = new Blob([pdfBytes], { type: 'application/pdf' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = fileName;
  link.click();

  // Create and download the PDF
const blobUrl = URL.createObjectURL(blob);

// 1. Open in a new tab
window.open(blobUrl, '_blank');
});


  document.querySelector('#resizetoA4').addEventListener("click", function(){
    document.querySelectorAll("img").forEach(function(e){
      e.style.width = "210mm";
      e.style.height = "297mm";
    })
  })

const select = document.getElementById('imageSelector');

  document.body.addEventListener('keydown', function(event) {
    let selectedIndex = select.selectedIndex;

    if (event.key === 'ArrowDown') {
      event.preventDefault();
      if (selectedIndex < select.options.length - 1) {
        select.selectedIndex = selectedIndex + 1;
        // Dispatch change event
        select.dispatchEvent(new Event('change'));
      }
    } else if (event.key === 'ArrowUp') {
      event.preventDefault();
      if (selectedIndex > 0) {
        select.selectedIndex = selectedIndex - 1;
        // Dispatch change event
        select.dispatchEvent(new Event('change'));
      }
    }
  });

  // Optional: listen for changes on the select
  select.addEventListener('change', () => {
    console.log('Selected image:', select.value);
  });

const slider = document.getElementById("rotationSlider");
  const angleDisplay = document.getElementById("angleValue");

  
document.querySelector('#invertcolor').addEventListener("click", function(){
    invertcolor();
  });

  function invertcolor(){    
    const ctx = document.querySelector("canvas").getContext('2d', { willReadFrequently: true });
    // Get the image data from the canvas
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;

    // Loop through every pixel and invert the colors
    for (let i = 0; i < data.length; i += 4) {
      // Invert Red, Green, Blue channels
      data[i] = 255 - data[i];     // Red
      data[i + 1] = 255 - data[i + 1]; // Green
      data[i + 2] = 255 - data[i + 2]; // Blue
      // Alpha (data[i + 3]) remains the same
    }

    // Put the modified image data back to the canvas
    ctx.putImageData(imageData, 0, 0);
  }

// Apply Gamma Correction
function applyGammaCorrection() {
    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");

    const gamma = 0.8;
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;

    for (let i = 0; i < data.length; i += 4) {
        data[i] = Math.pow(data[i] / 255, gamma) * 255;         // R
        data[i + 1] = Math.pow(data[i + 1] / 255, gamma) * 255; // G
        data[i + 2] = Math.pow(data[i + 2] / 255, gamma) * 255; // B
    }

    ctx.putImageData(imageData, 0, 0);
}

function applyRetinexToShadows(shadowThreshold = 80, alpha = 0.8) {
    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;
    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;

    const sigma = 15;

    // Calculate intensity (luminance) + offset
    const intensity = new Float32Array(width * height);
    for (let i = 0; i < data.length; i += 4) {
        const idx = i / 4;
        intensity[idx] = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2] + 1;
    }

    // Blur intensity
    const blurredIntensity = separableBoxBlur(intensity, width, height, sigma);

    // Compute Retinex intensity (log difference)
    const retinexIntensity = new Float32Array(width * height);
    let minVal = Infinity, maxVal = -Infinity;
    for (let i = 0; i < intensity.length; i++) {
        retinexIntensity[i] = Math.log(intensity[i]) - Math.log(blurredIntensity[i] + 1e-5);
        if (retinexIntensity[i] < minVal) minVal = retinexIntensity[i];
        if (retinexIntensity[i] > maxVal) maxVal = retinexIntensity[i];
    }
    const scale = 255 / (maxVal - minVal);

    for (let i = 0; i < data.length; i += 4) {
        const idx = i / 4;
        const pixelIntensity = (intensity[idx] - 1); // remove offset
        if (pixelIntensity < shadowThreshold) {
            // This is a shadow pixel ‚Äî apply Retinex enhancement here

            const normRetinex = (retinexIntensity[idx] - minVal) * scale;
            const origIntensity = intensity[idx];

            const factor = normRetinex / origIntensity;

            // Scale RGB by factor but blend with original color to keep naturalness
            data[i] = clamp(alpha * data[i] * factor + (1 - alpha) * data[i]);
            data[i + 1] = clamp(alpha * data[i + 1] * factor + (1 - alpha) * data[i + 1]);
            data[i + 2] = clamp(alpha * data[i + 2] * factor + (1 - alpha) * data[i + 2]);
        }
        // else: leave pixel unchanged
    }

    ctx.putImageData(imageData, 0, 0);
}

function smoothStep(edge0, edge1, x) {
    const t = Math.min(Math.max((x - edge0) / (edge1 - edge0), 0), 1);
    return t * t * (3 - 2 * t);
}



// Clamp value between 0 and 255
function clamp(val) {
    return val < 0 ? 0 : val > 255 ? 255 : val;
}

// Separable Box Blur (fast approx Gaussian blur)
// Blur radius ~ sigma; number of passes = 3 for better approx
function separableBoxBlur(src, width, height, sigma) {
    // Number of box blur passes - 3 is a good approx of Gaussian
    const passes = 3;

    // Calculate box sizes for approx Gaussian based on sigma
    // Formula from: https://www.peterkovesi.com/papers/FastGaussianSmoothing.pdf
    const boxSizes = calculateBoxesForGaussian(sigma, passes);

    let temp = new Float32Array(src.length);
    let out = new Float32Array(src.length);

    src.forEach((v, i) => temp[i] = v);

    for (let i = 0; i < passes; i++) {
        boxBlurHorizontal(temp, out, width, height, Math.floor((boxSizes[i] - 1) / 2));
        boxBlurVertical(out, temp, width, height, Math.floor((boxSizes[i] - 1) / 2));
    }

    return temp; // after odd passes, result is in temp
}

// Calculate sizes of boxes to approximate Gaussian blur with given sigma and passes
function calculateBoxesForGaussian(sigma, n) {
    // Ideal filter width
    const wIdeal = Math.sqrt((12 * sigma * sigma / n) + 1);
    let wl = Math.floor(wIdeal);
    if (wl % 2 === 0) wl--;
    const wu = wl + 2;

    const mIdeal = (12 * sigma * sigma - n * wl * wl - 4 * n * wl - 3 * n) / (-4 * wl - 4);
    const m = Math.round(mIdeal);

    const sizes = [];
    for (let i = 0; i < n; i++) {
        sizes.push(i < m ? wl : wu);
    }
    return sizes;
}

// Box blur horizontal pass
function boxBlurHorizontal(src, dst, width, height, radius) {
    const iarr = 1 / (radius + radius + 1);
    for (let y = 0; y < height; y++) {
        let ti = y * width, li = ti, ri = ti + radius;
        let val = 0;

        for (let i = 0; i < radius; i++) val += src[ti + i];
        for (let i = 0; i <= radius; i++) val += src[ri++];

        for (let x = 0; x < width; x++) {
            dst[ti++] = val * iarr;
            val -= src[li++];
            if (ri < (y + 1) * width) val += src[ri++];
        }
    }
}

// Box blur vertical pass
function boxBlurVertical(src, dst, width, height, radius) {
    const iarr = 1 / (radius + radius + 1);
    for (let x = 0; x < width; x++) {
        let ti = x, li = ti, ri = ti + radius * width;
        let val = 0;

        for (let i = 0; i < radius; i++) val += src[ti + i * width];
        for (let i = 0; i <= radius; i++) val += src[ri];
            ri += width;

        for (let y = 0; y < height; y++) {
            dst[ti] = val * iarr;
            ti += width;
            val -= src[li];
            li += width;
            if (ri < width * height) val += src[ri];
            ri += width;
        }
    }
}


// Box blur for luminance
function boxBlurLuminance(src, width, height, radius) {
    const dst = new Float32Array(width * height);
    const size = radius * 2 + 1;

    // Horizontal pass
    const temp = new Float32Array(width * height);
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            let sum = 0;
            let count = 0;
            for (let dx = -radius; dx <= radius; dx++) {
                const nx = x + dx;
                if (nx >= 0 && nx < width) {
                    sum += src[y * width + nx];
                    count++;
                }
            }
            temp[y * width + x] = sum / count;
        }
    }

    // Vertical pass
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            let sum = 0;
            let count = 0;
            for (let dy = -radius; dy <= radius; dy++) {
                const ny = y + dy;
                if (ny >= 0 && ny < height) {
                    sum += temp[ny * width + x];
                    count++;
                }
            }
            dst[y * width + x] = sum / count;
        }
    }

    return dst;
}

// RGB ‚Üí HSV
function rgbToHsv(r, g, b) {
    let max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, v = max;

    let d = max - min;
    s = max === 0 ? 0 : d / max;

    if (max === min) {
        h = 0;
    } else {
        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }

    return { h, s, v };
}

// HSV ‚Üí RGB
function hsvToRgb(h, s, v) {
    let r, g, b;

    let i = Math.floor(h * 6);
    let f = h * 6 - i;
    let p = v * (1 - s);
    let q = v * (1 - f * s);
    let t = v * (1 - (1 - f) * s);

    switch (i % 6) {
        case 0: r = v; g = t; b = p; break;
        case 1: r = q; g = v; b = p; break;
        case 2: r = p; g = v; b = t; break;
        case 3: r = p; g = q; b = v; break;
        case 4: r = t; g = p; b = v; break;
        case 5: r = v; g = p; b = q; break;
    }

    return { r, g, b };
}



// Apply Brightness Adjustment
function applyBrightnessAdjustment() {
    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");

    const brightness = 30;
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;

    for (let i = 0; i < data.length; i += 4) {
        data[i] = Math.min(Math.max(data[i] + brightness, 0), 255);
        data[i + 1] = Math.min(Math.max(data[i + 1] + brightness, 0), 255);
        data[i + 2] = Math.min(Math.max(data[i + 2] + brightness, 0), 255);
    }

    ctx.putImageData(imageData, 0, 0);
}

function globalContrastStretching(canvas = document.querySelector("canvas")) {
  if (!canvas) {
    console.error("Canvas element not found.");
    return;
  }

  const ctx = canvas.getContext("2d");
  if (!ctx) {
    console.error("2D context not available.");
    return;
  }

  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data;

  // Find the minimum and maximum pixel intensity (consider RGB channels only)
  let minIntensity = 255;
  let maxIntensity = 0;

  for (let i = 0; i < data.length; i += 4) {
    // Consider R, G, B channels
    minIntensity = Math.min(minIntensity, data[i], data[i + 1], data[i + 2]);
    maxIntensity = Math.max(maxIntensity, data[i], data[i + 1], data[i + 2]);
  }

  // Prevent division by zero in case min and max are equal
  const intensityRange = maxIntensity - minIntensity;
  if (intensityRange === 0) {
    console.warn("Image has uniform color; contrast stretching is not applicable.");
    return;
  }

  const scale = 255 / intensityRange;

  // Stretch contrast for each RGB pixel
  for (let i = 0; i < data.length; i += 4) {
    data[i] = Math.min(255, Math.max(0, Math.round((data[i] - minIntensity) * scale)));
    data[i + 1] = Math.min(255, Math.max(0, Math.round((data[i + 1] - minIntensity) * scale)));
    data[i + 2] = Math.min(255, Math.max(0, Math.round((data[i + 2] - minIntensity) * scale)));
    // Alpha channel remains unchanged (data[i + 3])
  }

  ctx.putImageData(imageData, 0, 0);
}

function toneMapReinhardWithExposure(canvas = document.querySelector("canvas"), exposure = 2.0) {
  if (!canvas) {
    console.error("Canvas element not found.");
    return;
  }

  const ctx = canvas.getContext("2d");
  if (!ctx) {
    console.error("2D context not available.");
    return;
  }

  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data;

  for (let i = 0; i < data.length; i += 4) {
    let r = data[i] / 255;
    let g = data[i + 1] / 255;
    let b = data[i + 2] / 255;

    // Scale RGB by exposure
    r *= exposure;
    g *= exposure;
    b *= exposure;

    // Compute luminance
    const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;

    // Reinhard tone mapping
    const toneMappedL = luminance / (1.0 + luminance);
    const scale = luminance > 0 ? toneMappedL / luminance : 0;

    // Apply tone mapping
    r = r * scale;
    g = g * scale;
    b = b * scale;

    data[i] = Math.min(255, Math.max(0, Math.round(r * 255)));
    data[i + 1] = Math.min(255, Math.max(0, Math.round(g * 255)));
    data[i + 2] = Math.min(255, Math.max(0, Math.round(b * 255)));
  }

  ctx.putImageData(imageData, 0, 0);
}

function applyMagicFilter(threshold = 180) {
    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;

    const histogram = new Array(256).fill(0);
    const luminances = [];

    // Step 1: Calculate luminance and collect foreground pixels
    for (let i = 0; i < data.length; i += 4) {
        const r = data[i], g = data[i + 1], b = data[i + 2];
        const lum = 0.299 * r + 0.587 * g + 0.114 * b;
        luminances.push(lum);

        if (lum < threshold) {
            histogram[Math.floor(lum)]++;
        }
    }

    // Step 2: Compute CDF (Cumulative Distribution Function)
    const cdf = new Array(256).fill(0);
    cdf[0] = histogram[0];
    for (let i = 1; i < 256; i++) {
        cdf[i] = cdf[i - 1] + histogram[i];
    }

    const cdfMin = cdf.find(v => v > 0);
    const totalPixels = cdf[255];
    const lookup = cdf.map(v =>
        totalPixels > cdfMin ? Math.round(((v - cdfMin) / (totalPixels - cdfMin)) * 255) : 0
    );

    // Step 3: Apply filter
    for (let i = 0; i < data.length; i += 4) {
        const lum = luminances[i / 4];

        if (lum < threshold) {
            // Foreground: apply histogram equalization
            data[i] = lookup[data[i]];
            data[i + 1] = lookup[data[i + 1]];
            data[i + 2] = lookup[data[i + 2]];
        } else {
            // Background: make it white
            data[i] = 255;
            data[i + 1] = 255;
            data[i + 2] = 255;
        }
    }

    ctx.putImageData(imageData, 0, 0);
}

function equalizeHSVValueHistogramWithMask(canvas = document.querySelector("canvas"), blendFactor = 0.5, mask = null) {
  const ctx = canvas.getContext("2d");
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data;

  const width = canvas.width;
  const height = canvas.height;

  const vHistogram = new Array(256).fill(0);
  const vValues = [];

  // Step 1: Build V histogram only from masked pixels
  for (let i = 0; i < data.length; i += 4) {
    const pixelIndex = i / 4;

    if (mask && !mask[pixelIndex]) continue;

    const r = data[i] / 255;
    const g = data[i + 1] / 255;
    const b = data[i + 2] / 255;

    const { h, s, v } = rgbToHsv(r, g, b);
    const vInt = Math.floor(v * 255);
    vHistogram[vInt]++;
    vValues.push({ h, s, v, index: i });
  }

  // Step 2: Compute CDF for masked region
  const cdf = new Array(256).fill(0);
  cdf[0] = vHistogram[0];
  for (let i = 1; i < 256; i++) {
    cdf[i] = cdf[i - 1] + vHistogram[i];
  }

  const cdfMin = cdf.find(v => v > 0);
  const total = cdf[255];
  const lookup = cdf.map(v =>
    total > cdfMin ? ((v - cdfMin) / (total - cdfMin)) : 0
  );

  // Step 3: Apply equalization only to masked pixels
  for (const { h, s, v, index } of vValues) {
    const vEq = lookup[Math.floor(v * 255)];
    const vBlended = blendFactor * vEq + (1 - blendFactor) * v;
    const { r, g, b } = hsvToRgb(h, s, vBlended);

    data[index] = Math.round(r * 255);
    data[index + 1] = Math.round(g * 255);
    data[index + 2] = Math.round(b * 255);
    // alpha remains unchanged
  }

  ctx.putImageData(imageData, 0, 0);
}


function rgbToHsv(r, g, b) {
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const delta = max - min;

  let h = 0;
  if (delta !== 0) {
    if (max === r) {
      h = ((g - b) / delta) % 6;
    } else if (max === g) {
      h = (b - r) / delta + 2;
    } else {
      h = (r - g) / delta + 4;
    }
    h *= 60;
    if (h < 0) h += 360;
  }

  const s = max === 0 ? 0 : delta / max;
  const v = max;
  return { h, s, v };
}

function hsvToRgb(h, s, v) {
  const c = v * s;
  const x = c * (1 - Math.abs((h / 60) % 2 - 1));
  const m = v - c;

  let r = 0, g = 0, b = 0;
  if (0 <= h && h < 60) {
    [r, g, b] = [c, x, 0];
  } else if (60 <= h && h < 120) {
    [r, g, b] = [x, c, 0];
  } else if (120 <= h && h < 180) {
    [r, g, b] = [0, c, x];
  } else if (180 <= h && h < 240) {
    [r, g, b] = [0, x, c];
  } else if (240 <= h && h < 300) {
    [r, g, b] = [x, 0, c];
  } else {
    [r, g, b] = [c, 0, x];
  }

  return {
    r: r + m,
    g: g + m,
    b: b + m
  };
}


function applyBiHistogramEqualizationWithEdgePreservation() {
    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;

    // Get original image data
    const originalImageData = ctx.getImageData(0, 0, width, height);
    const originalData = originalImageData.data;

    // Clone original to work on equalized image
    const equalizedImageData = ctx.getImageData(0, 0, width, height);
    const data = equalizedImageData.data;

    // ===== Step 1: Bi-Histogram Equalization on equalizedImageData =====
    // (Same as before, HSL based)
    // Build histogram and lightness array
    const histogram = new Array(256).fill(0);
    const lightnessValues = [];

    for (let i = 0; i < data.length; i += 4) {
        const r = data[i] / 255;
        const g = data[i + 1] / 255;
        const b = data[i + 2] / 255;

        const [h, s, l] = rgbToHsl(r, g, b);
        const lum = Math.round(l * 255);

        lightnessValues.push({ h, s, l, index: i });
        histogram[lum]++;
    }

    let sum = 0, total = lightnessValues.length;
    for (let i = 0; i < 256; i++) sum += i * histogram[i];
    const mean = Math.floor(sum / total);

    const cdfLower = new Array(256).fill(0);
    const cdfUpper = new Array(256).fill(0);
    let cdfL = 0, cdfU = 0;

    for (let i = 0; i <= mean; i++) {
        cdfL += histogram[i];
        cdfLower[i] = cdfL;
    }
    for (let i = mean + 1; i < 256; i++) {
        cdfU += histogram[i];
        cdfUpper[i] = cdfU;
    }

    const totalL = cdfLower[mean];
    const totalU = cdfUpper[255];
    const baseUpper = cdfUpper[mean];

    const map = new Array(256);
    for (let i = 0; i <= mean; i++) {
        map[i] = (cdfLower[i] / totalL) * mean;
    }
    for (let i = mean + 1; i < 256; i++) {
        map[i] = ((cdfUpper[i] - baseUpper) / (totalU - baseUpper)) * (255 - mean - 1) + mean + 1;
    }

    for (const { h, s, l, index } of lightnessValues) {
        const oldLum = Math.round(l * 255);
        const newLum = map[oldLum] / 255;
        const [r, g, b] = hslToRgb(h, s, newLum);

        data[index] = Math.round(r * 255);
        data[index + 1] = Math.round(g * 255);
        data[index + 2] = Math.round(b * 255);
    }

    // ===== Step 2: Edge-preserving sharpening =====
    // Blur original image (small kernel)
    const blurredOriginal = boxBlur(originalImageData, width, height);

    // Extract edges by subtracting blurred original from original
    const edges = new Uint8ClampedArray(originalData.length);
    for (let i = 0; i < originalData.length; i += 4) {
        edges[i]     = clamp(originalData[i]     - blurredOriginal.data[i]);
        edges[i + 1] = clamp(originalData[i + 1] - blurredOriginal.data[i + 1]);
        edges[i + 2] = clamp(originalData[i + 2] - blurredOriginal.data[i + 2]);
        edges[i + 3] = 255;
    }

    // Add edges back to equalized image with an amount factor
    const amount = 1.0; // tweak between 0 (no sharpening) to ~2 (strong)
    for (let i = 0; i < data.length; i += 4) {
        data[i]     = clamp(data[i]     + amount * edges[i]);
        data[i + 1] = clamp(data[i + 1] + amount * edges[i + 1]);
        data[i + 2] = clamp(data[i + 2] + amount * edges[i + 2]);
        // alpha unchanged
    }

    ctx.putImageData(equalizedImageData, 0, 0);
}

// Helpers (same as before) ...
function boxBlur(imageData, width, height) {
    const data = imageData.data;
    const result = new Uint8ClampedArray(data.length);
    const kernelSize = 3;
    const half = Math.floor(kernelSize / 2);

    const getIndex = (x, y) => 4 * (y * width + x);

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            let r = 0, g = 0, b = 0, count = 0;

            for (let ky = -half; ky <= half; ky++) {
                for (let kx = -half; kx <= half; kx++) {
                    const nx = x + kx;
                    const ny = y + ky;
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                        const idx = getIndex(nx, ny);
                        r += data[idx];
                        g += data[idx + 1];
                        b += data[idx + 2];
                        count++;
                    }
                }
            }

            const idx = getIndex(x, y);
            result[idx] = r / count;
            result[idx + 1] = g / count;
            result[idx + 2] = b / count;
            result[idx + 3] = data[idx + 3]; // alpha
        }
    }

    return new ImageData(result, width, height);
}

function clamp(value) {
    return Math.min(255, Math.max(0, value));
}

function rgbToHsl(r, g, b) {
    const max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h = 0, s = 0;
    const l = (max + min) / 2;

    if (max !== min) {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }

    return [h, s, l];
}

function hslToRgb(h, s, l) {
    if (s === 0) return [l, l, l];

    const hue2rgb = (p, q, t) => {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
    };

    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;

    const r = hue2rgb(p, q, h + 1/3);
    const g = hue2rgb(p, q, h);
    const b = hue2rgb(p, q, h - 1/3);

    return [r, g, b];
}



function applyGaussianBlur(kernelSize = 5, sigma = 1.0) {
    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const width = canvas.width, height = canvas.height;
    const data = imageData.data;
    const output = new Uint8ClampedArray(data);

    // Generate Gaussian kernel
    function gaussian(x, y) {
        return (1 / (2 * Math.PI * sigma * sigma)) *
            Math.exp(-(x * x + y * y) / (2 * sigma * sigma));
    }

    const half = Math.floor(kernelSize / 2);
    const kernel = [];
    let sum = 0;

    for (let y = -half; y <= half; y++) {
        for (let x = -half; x <= half; x++) {
            const g = gaussian(x, y);
            kernel.push(g);
            sum += g;
        }
    }

    // Normalize the kernel
    for (let i = 0; i < kernel.length; i++) {
        kernel[i] /= sum;
    }

    function getIndex(x, y) {
        return (y * width + x) * 4;
    }

    for (let y = half; y < height - half; y++) {
        for (let x = half; x < width - half; x++) {
            let r = 0, g = 0, b = 0;
            let k = 0;
            for (let ky = -half; ky <= half; ky++) {
                for (let kx = -half; kx <= half; kx++) {
                    const i = getIndex(x + kx, y + ky);
                    r += data[i] * kernel[k];
                    g += data[i + 1] * kernel[k];
                    b += data[i + 2] * kernel[k];
                    k++;
                }
            }

            const idx = getIndex(x, y);
            output[idx] = r;
            output[idx + 1] = g;
            output[idx + 2] = b;
        }
    }

    imageData.data.set(output);
    ctx.putImageData(imageData, 0, 0);
}

function applyGuidedFilter(radius = 8, epsilon = 0.02) {
    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const width = canvas.width, height = canvas.height;
    const data = imageData.data;
    const output = new Uint8ClampedArray(data.length);

    const N = (2 * radius + 1) ** 2;

    // Box filter with integral image for fast local sum calculation
    function boxFilter(img, width, height, r) {
        const result = new Float32Array(width * height);
        const integral = new Float32Array((width + 1) * (height + 1));

        // Compute integral image
        for (let y = 0; y < height; y++) {
            let sum = 0;
            for (let x = 0; x < width; x++) {
                sum += img[y * width + x];
                integral[(y + 1) * (width + 1) + (x + 1)] = integral[y * (width + 1) + (x + 1)] + sum;
            }
        }

        // Compute box filter by integral image sums
        for (let y = 0; y < height; y++) {
            const y1 = Math.max(0, y - r);
            const y2 = Math.min(height - 1, y + r);
            for (let x = 0; x < width; x++) {
                const x1 = Math.max(0, x - r);
                const x2 = Math.min(width - 1, x + r);

                const A = integral[y1 * (width + 1) + x1];
                const B = integral[y1 * (width + 1) + (x2 + 1)];
                const C = integral[(y2 + 1) * (width + 1) + x1];
                const D = integral[(y2 + 1) * (width + 1) + (x2 + 1)];

                result[y * width + x] = D - B - C + A;
            }
        }
        return result;
    }

    // Split channels R, G, B into separate float arrays normalized [0..1]
    const I_r = new Float32Array(width * height);
    const I_g = new Float32Array(width * height);
    const I_b = new Float32Array(width * height);

    for (let i = 0; i < width * height; i++) {
        const idx = i * 4;
        I_r[i] = data[idx] / 255;
        I_g[i] = data[idx + 1] / 255;
        I_b[i] = data[idx + 2] / 255;
    }

    // Guided filter helper for one channel
    function guidedFilterChannel(I) {
        // mean_I
        const mean_I = boxFilter(I, width, height, radius).map(v => v / N);
        // corr_I = mean of I*I
        const II = I.map(v => v * v);
        const corr_I = boxFilter(II, width, height, radius).map(v => v / N);

        // variance of I in window
        const var_I = new Float32Array(width * height);
        for (let i = 0; i < var_I.length; i++) {
            var_I[i] = corr_I[i] - mean_I[i] * mean_I[i];
        }

        // Since we're filtering the input image itself (p = I), covariance cov_Ip = var_I
        // a = cov_Ip / (var_I + epsilon) = var_I / (var_I + epsilon)
        const a = new Float32Array(width * height);
        for (let i = 0; i < a.length; i++) {
            a[i] = var_I[i] / (var_I[i] + epsilon);
        }

        // b = mean_p - a * mean_I; p = I, so mean_p = mean_I
        const b = new Float32Array(width * height);
        for (let i = 0; i < b.length; i++) {
            b[i] = mean_I[i] - a[i] * mean_I[i];
        }

        // mean_a and mean_b
        const mean_a = boxFilter(a, width, height, radius).map(v => v / N);
        const mean_b = boxFilter(b, width, height, radius).map(v => v / N);

        // q = mean_a * I + mean_b
        const q = new Float32Array(width * height);
        for (let i = 0; i < q.length; i++) {
            q[i] = mean_a[i] * I[i] + mean_b[i];
        }

        return q;
    }

    // Apply guided filter to each color channel
    const out_r = guidedFilterChannel(I_r);
    const out_g = guidedFilterChannel(I_g);
    const out_b = guidedFilterChannel(I_b);

    // Write back to output Uint8ClampedArray
    for (let i = 0; i < width * height; i++) {
        const idx = i * 4;
        output[idx] = Math.min(255, Math.max(0, Math.round(out_r[i] * 255)));
        output[idx + 1] = Math.min(255, Math.max(0, Math.round(out_g[i] * 255)));
        output[idx + 2] = Math.min(255, Math.max(0, Math.round(out_b[i] * 255)));
        output[idx + 3] = data[idx + 3]; // preserve alpha channel
    }

    // Update canvas with filtered image
    imageData.data.set(output);
    ctx.putImageData(imageData, 0, 0);
}


function applyMedianBlur(kernelSize = 3) {
    if (kernelSize % 2 === 0 || kernelSize < 1) {
        console.error("Kernel size must be an odd number >= 1.");
        return;
    }

    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const width = canvas.width;
    const height = canvas.height;
    const src = imageData.data;
    const dst = new Uint8ClampedArray(src.length);

    const half = Math.floor(kernelSize / 2);
    const windowSize = kernelSize * kernelSize;

    const rVals = new Uint8Array(windowSize);
    const gVals = new Uint8Array(windowSize);
    const bVals = new Uint8Array(windowSize);
    const aVals = new Uint8Array(windowSize);

    const getIndex = (x, y) => (y * width + x) * 4;

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            let count = 0;

            for (let ky = -half; ky <= half; ky++) {
                const ny = Math.min(height - 1, Math.max(0, y + ky));
                for (let kx = -half; kx <= half; kx++) {
                    const nx = Math.min(width - 1, Math.max(0, x + kx));
                    const idx = getIndex(nx, ny);

                    rVals[count] = src[idx];
                    gVals[count] = src[idx + 1];
                    bVals[count] = src[idx + 2];
                    aVals[count] = src[idx + 3];
                    count++;
                }
            }

            const mid = Math.floor(count / 2);
            const median = arr => {
                const copy = Array.from(arr.subarray(0, count));
                copy.sort((a, b) => a - b);
                return copy[mid];
            };

            const dstIdx = getIndex(x, y);
            dst[dstIdx]     = median(rVals);
            dst[dstIdx + 1] = median(gVals);
            dst[dstIdx + 2] = median(bVals);
            dst[dstIdx + 3] = median(aVals);
        }
    }

    imageData.data.set(dst);
    ctx.putImageData(imageData, 0, 0);
}


function downscaleImage(canvas, maxWidth, maxHeight) {
    const originalWidth = canvas.width;
    const originalHeight = canvas.height;

    // Don't upscale
    if (originalWidth <= maxWidth && originalHeight <= maxHeight) return;

    let scale = Math.min(maxWidth / originalWidth, maxHeight / originalHeight);

    // Use an offscreen canvas to preserve the original
    let offCanvas = document.createElement("canvas");
    let offCtx = offCanvas.getContext("2d");

    offCanvas.width = originalWidth;
    offCanvas.height = originalHeight;
    offCtx.drawImage(canvas, 0, 0);

    let currentWidth = originalWidth;
    let currentHeight = originalHeight;

    // Progressive downscale
    while (currentWidth * scale > maxWidth * 1.5 || currentHeight * scale > maxHeight * 1.5) {
        currentWidth = Math.floor(currentWidth * 0.5);
        currentHeight = Math.floor(currentHeight * 0.5);

        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = currentWidth;
        tempCanvas.height = currentHeight;
        const tempCtx = tempCanvas.getContext("2d");

        tempCtx.drawImage(offCanvas, 0, 0, offCanvas.width, offCanvas.height, 0, 0, currentWidth, currentHeight);

        offCanvas = tempCanvas;
        offCtx = tempCtx;
    }

    // Final downscale to target size
    const finalWidth = Math.floor(originalWidth * scale);
    const finalHeight = Math.floor(originalHeight * scale);

    canvas.width = finalWidth;
    canvas.height = finalHeight;

    const finalCtx = canvas.getContext("2d");
    finalCtx.drawImage(offCanvas, 0, 0, offCanvas.width, offCanvas.height, 0, 0, finalWidth, finalHeight);

    // Replace image with warped version
  const newImg = new Image();  
  newImg.src = canvas.toDataURL();
  newImg.onload = () => {
    images[currentImageIndex] = new ImageObject(newImg);
    loadCurrentImage();
  };
}

function upscaleAndSharpen(canvas, maxWidth, maxHeight) {
    const originalWidth = canvas.width;
    const originalHeight = canvas.height;

    // Calculate scale to maintain aspect ratio
    const scale = Math.min(maxWidth / originalWidth, maxHeight / originalHeight);

    // Calculate new dimensions
    const targetWidth = Math.floor(originalWidth * scale);
    const targetHeight = Math.floor(originalHeight * scale);

    // Create offscreen canvas to perform upscale
    const upscaleCanvas = document.createElement("canvas");
    upscaleCanvas.width = targetWidth;
    upscaleCanvas.height = targetHeight;
    const upscaleCtx = upscaleCanvas.getContext("2d");

    // Enable high-quality image smoothing
    upscaleCtx.imageSmoothingEnabled = true;
    upscaleCtx.imageSmoothingQuality = "high";

    // Draw the original image scaled to target size
    upscaleCtx.drawImage(canvas, 0, 0, targetWidth, targetHeight);

    // Get image data for sharpening
    const imageData = upscaleCtx.getImageData(0, 0, targetWidth, targetHeight);
    const data = imageData.data;

    // Sharpen kernel matrix (3x3)
    const kernel = [
         0, -1,  0,
        -1,  5, -1,
         0, -1,  0
    ];

    // Copy original image data to avoid overwriting during convolution
    const copy = new Uint8ClampedArray(data);

    const width = targetWidth;
    const height = targetHeight;
    const kernelSize = 3;
    const half = Math.floor(kernelSize / 2);

    // Apply sharpening filter
    for (let y = half; y < height - half; y++) {
        for (let x = half; x < width - half; x++) {
            for (let c = 0; c < 3; c++) { // Loop over R, G, B channels
                let i = (y * width + x) * 4 + c;
                let sum = 0;

                for (let ky = -half; ky <= half; ky++) {
                    for (let kx = -half; kx <= half; kx++) {
                        const ii = ((y + ky) * width + (x + kx)) * 4 + c;
                        const weight = kernel[(ky + half) * kernelSize + (kx + half)];
                        sum += copy[ii] * weight;
                    }
                }

                // Clamp the result between 0 and 255
                data[i] = Math.min(255, Math.max(0, sum));
            }
        }
    }

    // Update canvas with sharpened image data
    upscaleCtx.putImageData(imageData, 0, 0);

    // Resize original canvas and draw the processed image back
    canvas.width = targetWidth;
    canvas.height = targetHeight;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(upscaleCanvas, 0, 0);

    // Update any image references if you track them
    const newImg = new Image();
    newImg.src = canvas.toDataURL();
    newImg.onload = () => {
        images[currentImageIndex] = new ImageObject(newImg);
        loadCurrentImage();
    };
}


function enhanceCanvasImageColorAndSharpen() {
  const canvas = document.querySelector("canvas");
  if (!canvas) {
    console.warn("No canvas found in the document.");
    return;
  }

  const ctx = canvas.getContext("2d");
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data;

  // 1. Contrast Stretching per channel (R, G, B)
  for (let channel = 0; channel < 3; channel++) {
    let min = 255, max = 0;
    for (let i = channel; i < data.length; i += 4) {
      const val = data[i];
      if (val < min) min = val;
      if (val > max) max = val;
    }

    const scale = 255 / (max - min);
    for (let i = channel; i < data.length; i += 4) {
      data[i] = Math.min(255, Math.max(0, (data[i] - min) * scale));
    }
  }

  // 2. Sharpen using convolution kernel
  const kernel = [
     0, -1,  0,
    -1,  5, -1,
     0, -1,  0
  ];

  const width = canvas.width;
  const height = canvas.height;
  const output = new Uint8ClampedArray(data.length);

  const getIndex = (x, y) => (y * width + x) * 4;

  for (let y = 1; y < height - 1; y++) {
    for (let x = 1; x < width - 1; x++) {
      for (let c = 0; c < 3; c++) { // R, G, B
        let sum = 0;
        let k = 0;

        for (let ky = -1; ky <= 1; ky++) {
          for (let kx = -1; kx <= 1; kx++) {
            const px = x + kx;
            const py = y + ky;
            const idx = getIndex(px, py);
            sum += data[idx + c] * kernel[k];
            k++;
          }
        }

        const i = getIndex(x, y);
        output[i + c] = Math.min(255, Math.max(0, sum));
      }

      // Copy alpha channel
      const i = getIndex(x, y);
      output[i + 3] = data[i + 3];
    }
  }

  // 3. Put enhanced data back to canvas
  for (let i = 0; i < data.length; i++) {
    data[i] = output[i];
  }

  ctx.putImageData(imageData, 0, 0);
}

let selectedPagesToRemove = {}; // Map of file name to array of page indices to skip

document.getElementById('mergePdfBtn').addEventListener('click', async () => {
      const pdfDoc = await PDFLib.PDFDocument.create();

      const processPdfFile = async (file) => {
  const pdfBytes = await file.arrayBuffer();
  const existingPdfDoc = await PDFLib.PDFDocument.load(pdfBytes);

  const totalPages = existingPdfDoc.getPageCount();
  const fileName = file.name;
  const pagesToSkip = selectedPagesToRemove[fileName] || [];

  const pageIndices = [...Array(totalPages).keys()].filter(index => !pagesToSkip.includes(index));

  const copiedPages = await pdfDoc.copyPages(existingPdfDoc, pageIndices);
  copiedPages.forEach(page => pdfDoc.addPage(page));
};


      // Process all the selected files in the order they appear
      for (const fileObj of fileListPdf) {
        const file = fileObj.file;
        if (file.type === 'application/pdf') {
          await processPdfFile(file);
        }
      }

      // Serialize the PDF to bytes
      const pdfBytes = await pdfDoc.save();

    //   // Download the PDF
    //   const blob = new Blob([pdfBytes], { type: 'application/pdf' });
    //   const link = document.createElement('a');
    //   link.href = URL.createObjectURL(blob);
    //   link.download = 'combined.pdf';
    //   link.click();

      // Get the input value
let pdfName = document.querySelector("#filename").value.trim();

if (!pdfName) {
  // If the input is empty, use the current date and time as filename
  const now = new Date();
  const formattedDate = now.toISOString().replace(/[:.]/g, '-'); // Remove characters not safe for filenames
  pdfName = `PDF_${formattedDate}`;
}

// Ensure the file name ends with ".pdf"
const fileName = pdfName.endsWith('.pdf') ? pdfName : `${pdfName}.pdf`;

// Create and download the PDF
const blob = new Blob([pdfBytes], { type: 'application/pdf' });
const blobUrl = URL.createObjectURL(blob);

// 1. Open in a new tab
window.open(blobUrl, '_blank');

// 2. Trigger a download (optional)
const link = document.createElement('a');
link.href = blobUrl;
link.download = fileName;
link.click();

// 3. Clean up
setTimeout(() => URL.revokeObjectURL(blobUrl), 5000);

/*
const blob = new Blob([pdfBytes], { type: 'application/pdf' });
const blobUrl = URL.createObjectURL(blob);

// Ask the user
const userChoice = confirm("Click OK to preview the merged PDF.\nClick Cancel to download it.");

// Handle user's choice
if (userChoice) {
  // Open in Chrome PDF viewer (new tab)
  window.open(blobUrl, '_blank');
} else {
  // Get the file name input
  let pdfName = document.querySelector("#filename").value.trim();
  if (!pdfName) {
    const now = new Date();
    const formattedDate = now.toISOString().replace(/[:.]/g, '-');
    pdfName = `PDF_${formattedDate}`;
  }

  const fileName = pdfName.endsWith('.pdf') ? pdfName : `${pdfName}.pdf`;

  // Download the PDF
  const link = document.createElement('a');
  link.href = blobUrl;
  link.download = fileName;
  link.click();
}

// Revoke the object URL after a delay
setTimeout(() => URL.revokeObjectURL(blobUrl), 5000);
*/

    });

document.getElementById('downloadFirstPages').addEventListener('click', async () => {
  const newPdfDoc = await PDFLib.PDFDocument.create();

  const fileList = fileListPdf.filter(f => f.file.type === 'application/pdf');

  if (fileList.length === 0) {
    alert('No PDFs found in the uploaded files.');
    return;
  }

  for (const { file } of fileList) {
    const bytes = await file.arrayBuffer();
    const originalPdf = await PDFLib.PDFDocument.load(bytes);
    const [firstPage] = await newPdfDoc.copyPages(originalPdf, [0]);
    newPdfDoc.addPage(firstPage);
  }

  const newPdfBytes = await newPdfDoc.save();

  const blob = new Blob([newPdfBytes], { type: 'application/pdf' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = 'first_pages_only.pdf';
  link.click();
  
  generatefidaPDF();
});

document.getElementById('cropPdf').addEventListener('click', async function () {
  const pdfFiles = fileListPdf.filter(f => f.file.type === 'application/pdf');

  if (pdfFiles.length === 0) {
    alert('No PDFs found in the uploaded files.');
    return;
  }

  const reader = new FileReader();
  const croppedPdfDoc = await PDFLib.PDFDocument.create();

  // Convert inches to points (1 inch = 72 points)
  const topCrop = 3.5 * 72;
  const bottomCrop = 2.5 * 72;

  for (const { file } of pdfFiles) {
    const arrayBuffer = await file.arrayBuffer();
    const pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);
    const pages = pdfDoc.getPages();

    pages.forEach(page => {
      const { width, height } = page.getSize();
      page.setCropBox(0, topCrop, width, height - topCrop - bottomCrop);
    });

    //const copiedPages = await croppedPdfDoc.copyPages(pdfDoc, pdfDoc.getPageIndices());For Allpages
    const copiedPages = await croppedPdfDoc.copyPages(pdfDoc, [0]);//For First Page Only
    copiedPages.forEach(page => croppedPdfDoc.addPage(page));
  }

  const croppedPdfBytes = await croppedPdfDoc.save();

  const blob = new Blob([croppedPdfBytes], { type: 'application/pdf' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = 'cropped.pdf';
  link.click();
});

document.getElementById('twopagecrop').addEventListener('click', async function () {
  const pdfFiles = fileListPdf.filter(f => f.file.type === 'application/pdf');

  if (pdfFiles.length === 0) {
    alert('No PDFs found in the uploaded files.');
    return;
  }

  const croppedPdfDoc = await PDFLib.PDFDocument.create();

  // Convert inches to points (1 inch = 72 points)
  const topCrop = 0 * 72;
  const bottomCrop = 4 * 72;
  const leftCrop = 3 * 72;
  const rightCrop = 1.7 * 72;

  for (const { file } of pdfFiles) {
    const arrayBuffer = await file.arrayBuffer();
    const pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);
    const pages = pdfDoc.getPages();

    pages.forEach(page => {
      const { width, height } = page.getSize();

      const cropX = leftCrop;
      const cropY = bottomCrop;
      const cropWidth = width - leftCrop - rightCrop;
      const cropHeight = height - bottomCrop - topCrop;

      // ‚úÖ Apply the crop box correctly
      page.setCropBox(cropX, cropY, cropWidth, cropHeight);

      // Optional: force trim box and media box too, to match
      page.setMediaBox(cropX, cropY, cropWidth, cropHeight);
      page.setTrimBox(cropX, cropY, cropWidth, cropHeight);
    });

    const copiedPages = await croppedPdfDoc.copyPages(pdfDoc, pdfDoc.getPageIndices());
    copiedPages.forEach(page => croppedPdfDoc.addPage(page));
  }

  const croppedPdfBytes = await croppedPdfDoc.save();

  const blob = new Blob([croppedPdfBytes], { type: 'application/pdf' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = 'cropped.pdf';
  link.click();
});

        function enhancePhoto(canvas, contrastFactor = 1.1, sharpenStrength = 1.0) {
    const ctx = canvas.getContext("2d");
    const { width, height } = canvas;
    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;

    // Step 1: Contrast Boost (linear)
    for (let i = 0; i < data.length; i += 4) {
        for (let j = 0; j < 3; j++) { // R, G, B
            let val = data[i + j];
            val = (val - 128) * contrastFactor + 128;
            data[i + j] = Math.max(0, Math.min(255, val));
        }
    }

    // Step 2: Clone image for blur (for unsharp mask)
    const blurredData = new Uint8ClampedArray(data);
    const blurRadius = 1;
    const kernel = [1, 2, 1, 2, 4, 2, 1, 2, 1];
    const kernelSum = 16;

    function blurPixel(x, y, c) {
        const get = (dx, dy) => {
            const nx = Math.min(width - 1, Math.max(0, x + dx));
            const ny = Math.min(height - 1, Math.max(0, y + dy));
            return data[(ny * width + nx) * 4 + c];
        };

        const weightedSum =
              get(-1, -1) * 1 + get(0, -1) * 2 + get(1, -1) * 1 +
              get(-1,  0) * 2 + get(0,  0) * 4 + get(1,  0) * 2 +
              get(-1,  1) * 1 + get(0,  1) * 2 + get(1,  1) * 1;

        return weightedSum / kernelSum;
    }

    // Step 3: Unsharp Mask
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const i = (y * width + x) * 4;
            for (let c = 0; c < 3; c++) { // R, G, B
                const blurred = blurPixel(x, y, c);
                const orig = data[i + c];
                const sharpened = orig + sharpenStrength * (orig - blurred);
                blurredData[i + c] = Math.max(0, Math.min(255, sharpened));
            }
            blurredData[i + 3] = 255; // Alpha
        }
    }

    // Step 4: Apply final image
    const finalImage = new ImageData(blurredData, width, height);
    ctx.putImageData(finalImage, 0, 0);
}


async function generatefidaPDF() {
            const { jsPDF } = window.jspdf;
            const today = new Date();
            const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", 
                            "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            const formattedDate = `${String(today.getDate()).padStart(2, '0')}-${months[today.getMonth()]}-${today.getFullYear()}`;

            const doc = new jsPDF({ orientation: "landscape", format: "a4" });

            // Add date
            doc.setFont("Helvetica", "normal");
            doc.setFontSize(25);
            doc.text(`Date: ${formattedDate}`, 35, 30);

            // Bold and center within right half
            doc.setFont("Helvetica", "bold");
            const text = "Fida Hussain";
            doc.text(text, 65, 70);

            // Show number of pages
            doc.setFont("Helvetica", "normal");
            //doc.text("No of printed pages: " + pages, 20, 90);
            //doc.text("No of printed pages: " + document.querySelectorAll('.pdf-page-count').length, 35, 90);
            doc.text("No of printed pages: " + fileListPdf.length, 35, 90);

            // Signature line
            doc.text("Signature: ____________", 35, 150);

            // Add date
            doc.setFont("Helvetica", "normal");
            doc.setFontSize(25);
            doc.text(`Date:        -${months[today.getMonth()]}-${today.getFullYear()}`, 170, 30);

            // Bold and center within right half
            doc.setFont("Helvetica", "bold");            
            doc.text("Fida Hussain", 220, 70);

            // Show number of pages
            doc.setFont("Helvetica", "normal");
            //doc.text("No of printed pages: " + pages, 20, 90);
            doc.text("No of printed pages: ", 170, 90);

            // Signature line
            doc.text("Signature: ____________", 170, 150);

            doc.save("fida_hussain " + formattedDate + ".pdf");
        }

function matchHistogram(referenceRegion, shadowRegion) {
    const refHist = new Array(256).fill(0);
    const shdHist = new Array(256).fill(0);

    for (const val of referenceRegion) refHist[val]++;
    for (const val of shadowRegion) shdHist[val]++;

    const refCdf = new Array(256).fill(0);
    const shdCdf = new Array(256).fill(0);
    refCdf[0] = refHist[0];
    shdCdf[0] = shdHist[0];

    for (let i = 1; i < 256; i++) {
        refCdf[i] = refCdf[i - 1] + refHist[i];
        shdCdf[i] = shdCdf[i - 1] + shdHist[i];
    }

    const mapping = new Uint8Array(256);
    let j = 0;
    for (let i = 0; i < 256; i++) {
        while (j < 255 && shdCdf[i] > refCdf[j]) j++;
        mapping[i] = j;
    }

    return mapping;
}

function applyHistogramCorrection(mapping) {
    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;

    for (let i = 0; i < data.length; i += 4) {
        data[i] = mapping[data[i]];
        data[i + 1] = mapping[data[i + 1]];
        data[i + 2] = mapping[data[i + 2]];
    }

    ctx.putImageData(imageData, 0, 0);
}

function segmentImageByLuminance(threshold = 100) {
    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;

    for (let i = 0; i < data.length; i += 4) {
        const lum = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
        const val = lum < threshold ? 0 : 255;
        data[i] = data[i + 1] = data[i + 2] = val;
    }

    ctx.putImageData(imageData, 0, 0);
}

function applySobelEdgeDetection() {
    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    const width = canvas.width;
    const height = canvas.height;

    const grayscale = new Uint8ClampedArray(width * height);
    for (let i = 0; i < data.length; i += 4) {
        const lum = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
        grayscale[i / 4] = lum;
    }

    const sobelData = new Uint8ClampedArray(data.length);
    const gx = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
    const gy = [-1, -2, -1, 0, 0, 0, 1, 2, 1];

    for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
            let sumX = 0, sumY = 0;
            for (let ky = -1; ky <= 1; ky++) {
                for (let kx = -1; kx <= 1; kx++) {
                    const px = x + kx;
                    const py = y + ky;
                    const val = grayscale[py * width + px];
                    const idx = (ky + 1) * 3 + (kx + 1);
                    sumX += val * gx[idx];
                    sumY += val * gy[idx];
                }
            }
            const mag = Math.sqrt(sumX ** 2 + sumY ** 2);
            const i = (y * width + x) * 4;
            sobelData[i] = sobelData[i + 1] = sobelData[i + 2] = mag;
            sobelData[i + 3] = 255;
        }
    }

    const newImageData = new ImageData(sobelData, width, height);
    ctx.putImageData(newImageData, 0, 0);
}

function applyCorrection(shadowMask, imageData, mappings) {
    const data = imageData.data;

    for (let i = 0, j = 0; i < data.length; i += 4, j++) {
        if (shadowMask[j]) {
            data[i] = mappings.rMap[data[i]];
            data[i + 1] = mappings.gMap[data[i + 1]];
            data[i + 2] = mappings.bMap[data[i + 2]];
        }
    }

    return imageData;
}

function matchHistogram(source, reference) {
    const histSize = 256;
    const srcHist = new Array(histSize).fill(0);
    const refHist = new Array(histSize).fill(0);

    for (let val of source) srcHist[val]++;
    for (let val of reference) refHist[val]++;

    // Normalize histograms
    const srcCdf = cumulativeDistribution(srcHist, source.length);
    const refCdf = cumulativeDistribution(refHist, reference.length);

    // Create lookup table
    const mapping = new Uint8ClampedArray(256);
    let refIdx = 0;
    for (let srcIdx = 0; srcIdx < 256; srcIdx++) {
        while (refIdx < 255 && refCdf[refIdx] < srcCdf[srcIdx]) {
            refIdx++;
        }
        mapping[srcIdx] = refIdx;
    }

    return mapping;
}

function cumulativeDistribution(hist, total) {
    let cdf = [];
    let sum = 0;
    for (let i = 0; i < hist.length; i++) {
        sum += hist[i];
        cdf[i] = sum / total;
    }
    return cdf;
}

function computeHistogramMapping(shadowMask, imageData) {
    const data = imageData.data;
    const shadowPixels = [[], [], []]; // R, G, B
    const nonShadowPixels = [[], [], []];

    for (let i = 0, j = 0; i < data.length; i += 4, j++) {
        const r = data[i], g = data[i + 1], b = data[i + 2];

        if (shadowMask[j]) {
            shadowPixels[0].push(r);
            shadowPixels[1].push(g);
            shadowPixels[2].push(b);
        } else {
            nonShadowPixels[0].push(r);
            nonShadowPixels[1].push(g);
            nonShadowPixels[2].push(b);
        }
    }

    const mappings = [0, 1, 2].map(channel =>
        matchHistogram(shadowPixels[channel], nonShadowPixels[channel])
    );

    return {
        rMap: mappings[0],
        gMap: mappings[1],
        bMap: mappings[2],
    };
}

function detectShadowMask(imageData, threshold = 60) {
    const data = imageData.data;
    const width = imageData.width;
    const height = imageData.height;
    const mask = new Uint8ClampedArray(width * height); // 0 = non-shadow, 1 = shadow

    for (let i = 0, j = 0; i < data.length; i += 4, j++) {
        // Convert to grayscale
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const gray = 0.299 * r + 0.587 * g + 0.114 * b;

        // Shadow if below threshold
        mask[j] = gray < threshold ? 1 : 0;
    }

    return mask;
}

function detectShadowMaskHSV(imageData, valueDrop = 0.4, satDrop = 0.3) {
    const data = imageData.data;
    const width = imageData.width;
    const height = imageData.height;
    const mask = new Uint8ClampedArray(width * height);

    for (let i = 0, j = 0; i < data.length; i += 4, j++) {
        const r = data[i] / 255;
        const g = data[i + 1] / 255;
        const b = data[i + 2] / 255;

        const { h, s, v } = rgbToHsv(r, g, b);

        // Use low brightness (v) and low saturation (s) to identify shadow-like pixels
        if (v < valueDrop && s < satDrop) {
            mask[j] = 1;
        } else {
            mask[j] = 0;
        }
    }

    return mask;
}

function rgbToHsv(r, g, b) {
    const max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h = 0, s, v = max;
    const d = max - min;

    s = max === 0 ? 0 : d / max;

    if (max !== min) {
        if (max === r) h = (g - b) / d + (g < b ? 6 : 0);
        else if (max === g) h = (b - r) / d + 2;
        else if (max === b) h = (r - g) / d + 4;
        h /= 6;
    }

    return { h, s, v };
}

document.querySelector('#generatepptx').addEventListener('click', async () => {
  const pptx = new PptxGenJS();
  pptx.defineLayout({ name: 'A4', width: 8.27, height: 11.69 });
  pptx.layout = 'A4';

  //document.querySelectorAll("svg image").forEach(function(e) {
//    let href = e.getAttribute("href") || e.getAttribute("xlink:href");
    //if (href) {
        //window.open(href, '_blank');
    //}
//});

  const images = document.querySelectorAll('img');

  for (let img of images) {
    if (img.src.startsWith("data:image")) {
      const slide = pptx.addSlide();
      slide.addImage({
        data: img.src, // use base64 directly
        x: 0,
        y: 0,
        w: 8.27,
        h: 11.69
      });
    }
  }

  

  pptx.writeFile("a4-images-presentation.pptx");
});

document.querySelector("#idcardcapture").addEventListener("click", async () => {
  let stream;

  const videoContainer = document.getElementById("video-container");
  const video = document.getElementById("camera");
  const capturedPhoto = document.getElementById("capturedPhoto");

  // Create or get buttons container
  let buttonsContainer = document.getElementById("buttons-container");
  if (!buttonsContainer) {
    buttonsContainer = document.createElement("div");
    buttonsContainer.id = "buttons-container";
    Object.assign(buttonsContainer.style, {
      marginTop: "10px",
      display: "flex",
      justifyContent: "center",
      gap: "10px",
    });
    document.body.appendChild(buttonsContainer);
  }
  buttonsContainer.style.display = "flex";

  // Helper to create button if missing
  function createButton(id, text, display = "inline-block") {
    let btn = buttonsContainer.querySelector(`#${id}`);
    if (!btn) {
      btn = document.createElement("button");
      btn.id = id;
      btn.textContent = text;
      buttonsContainer.appendChild(btn);
    }
    btn.style.display = display;
    btn.setAttribute("aria-label", text);
    return btn;
  }

  const captureBtn = createButton("captureBtn", "üì∏ Capture");
  const resetBtn = createButton("resetBtn", "üîÑ Retake", "none");
  const captureAnotherBtn = createButton("captureAnotherBtn", "Capture Another", "none");

  // Disable capture button until video is ready
  captureBtn.disabled = true;

  async function startCamera() {
    if (stream) {
      stream.getTracks().forEach(t => t.stop());
    }

    try {
      stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
      video.srcObject = stream;
      video.muted = true;
      await video.play();

      videoContainer.style.display = "block";
      capturedPhoto.style.display = "none";

      captureBtn.style.display = "inline-block";
      captureBtn.disabled = false; // enable capture now that video is playing
      resetBtn.style.display = "none";
      captureAnotherBtn.style.display = "none";
    } catch (err) {
      alert("Camera access failed: " + err.message);
      console.error(err);
    }
  }

  function capturePhoto() {
    if (!video.videoWidth || !video.videoHeight) {
      return alert("Video not ready");
    }

    const canvas = document.createElement("canvas");
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    canvas.getContext("2d").drawImage(video, 0, 0);

    // Use quality parameter (0.8)
    capturedPhoto.src = canvas.toDataURL("image/jpeg", 0.8);

    if (stream) {
      stream.getTracks().forEach(t => t.stop());
      stream = null;
    }

    videoContainer.style.display = "none";
    capturedPhoto.style.display = "block";

    captureBtn.style.display = "none";
    resetBtn.style.display = "inline-block";
    captureAnotherBtn.style.display = "inline-block";
  }

  function resetCamera() {
    capturedPhoto.src = "";
    capturedPhoto.style.display = "none";
    videoContainer.style.display = "block";

    captureBtn.disabled = true; // disable until video ready again

    startCamera();
  }

  captureBtn.onclick = capturePhoto;
  resetBtn.onclick = resetCamera;
  captureAnotherBtn.onclick = resetCamera;

  // Clean up stream on page unload
  window.addEventListener("beforeunload", () => {
    if (stream) {
      stream.getTracks().forEach(t => t.stop());
    }
  });

  startCamera();
});

document.querySelector('#idcardsgenerate').addEventListener("click", function(){
// Clone the table node
  const clonedNode = document.querySelector('#array table').cloneNode(true);
  // Set padding style
  clonedNode.style.paddingTop = '0.1in';
  clonedNode.style.margin = '0 auto';
  clonedNode.style.borderSpacing = '45px 15px';
  clonedNode.dir = "rtl"
  // Append the cloned node
  document.querySelector("#array").appendChild(clonedNode);

const imgSrc = URL.createObjectURL(fileListPdf[0].file);
const img = document.createElement("img");
img.src = imgSrc;

// Ask the user how many <td> elements should receive the image
let numAppends = parseInt(prompt("How many <td> cells should get the image?"), 10);

// Select all <td> elements
const tdElements = document.querySelectorAll("table:nth-child(1) td");

let count = 0;
tdElements.forEach((td, index) => {
  if (count < numAppends && !td.querySelector("img")) {
    td.appendChild(img.cloneNode(true));

    const chi = document.createElement("img");
    chi.src = URL.createObjectURL(fileListPdf[1].file);
    document.querySelectorAll("table:nth-child(2) td")[index].appendChild(chi);
    
    count++;
  }
});

document.querySelectorAll("img").forEach(function(e){
      e.style.width = "3.4in";
      e.style.height = "2.2in";
    });
    document.querySelector("table").style.margin = "0 auto";
    document.querySelector("table").style.borderSpacing = "45px 15px";
    document.querySelector("table").style.pageBreakAfter = "always";

    /*

    // Ask the user
  const printType = confirm("Click OK for double-sided printing, or Cancel for single-sided printing.");

if (printType) {
  // Clone the table node
  const clonedNode = document.querySelector('#array table').cloneNode(true);

  // Set padding style
  clonedNode.style.paddingTop = '0.1in';

  // Append the cloned node
  document.querySelector("#array").appendChild(clonedNode);
  window.print();
} else{
  window.print();
  window.print();
}
  */

})

/*
document.querySelector('#embedsvgimages').addEventListener("click", function(){
  document.querySelectorAll("svg image").forEach(function(e) {
    let href = e.getAttribute("href") || e.getAttribute("xlink:href");
    if (href) {
        window.open(href, '_blank');
    }
});
})
*/

document.querySelector('#embedsvgimages').addEventListener("click", async function () {
  const images = document.querySelectorAll("svg image");
  for (const e of images) {
    const href = e.getAttribute("href") || e.getAttribute("xlink:href");
    if (href) {
      try {
        const response = await fetch(href);
        const blob = await response.blob();
        const file = new File([blob], "embedded-image.png", { type: blob.type });
        await processFile(file);
      } catch (err) {
        console.error(`Error processing image ${href}:`, err);
      }
    }
  }
});

/*
document.querySelector('#embedsvgimages').addEventListener("click", async function () {
const images = document.querySelectorAll("svg image");
for (const e of images) {
  const href = e.getAttribute("href") || e.getAttribute("xlink:href");
  if (href) {
    try {
      const response = await fetch(href);
      const blob = await response.blob();

      // Load image to check its dimensions
      const img = new Image();
      const objectURL = URL.createObjectURL(blob);

      await new Promise((resolve, reject) => {
        img.onload = () => {
          // Skip small watermark images, e.g., width < 100 and height < 50
          if (img.width < 100 && img.height < 50) {
            console.log("Skipped small image (possible watermark):", href);
            resolve(); // skip processing
          } else {
            const file = new File([blob], "embedded-image.png", { type: blob.type });
            processFile(file).then(resolve).catch(reject);
          }
          URL.revokeObjectURL(objectURL);
        };
        img.onerror = reject;
        img.src = objectURL;
      });
    } catch (err) {
      console.error(`Error processing image ${href}:`, err);
    }
  }
}
});
*/

function otsuThreshold(gray) {
    const hist = new Array(256).fill(0);
    const total = gray.length;

    for (let i = 0; i < gray.length; i++) {
        hist[gray[i]]++;
    }

    let sum = 0;
    for (let t = 0; t < 256; t++) sum += t * hist[t];

    let sumB = 0, wB = 0, wF = 0, varMax = 0;
    let threshold = 0;

    for (let t = 0; t < 256; t++) {
        wB += hist[t];
        if (wB === 0) continue;

        wF = total - wB;
        if (wF === 0) break;

        sumB += t * hist[t];

        const mB = sumB / wB;
        const mF = (sum - sumB) / wF;

        const varBetween = wB * wF * (mB - mF) ** 2;
        if (varBetween > varMax) {
            varMax = varBetween;
            threshold = t;
        }
    }

    return threshold;
}

function segmentImageByOtsu() {
    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;
    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;

    const gray = new Uint8Array(width * height);
    for (let i = 0; i < data.length; i += 4) {
        gray[i / 4] = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
    }

    const threshold = otsuThreshold(gray);
    console.log("Otsu Threshold:", threshold);

    for (let i = 0; i < gray.length; i++) {
        const val = gray[i] < threshold ? 0 : 255;
        const idx = i * 4;
        data[idx] = data[idx + 1] = data[idx + 2] = val;
        data[idx + 3] = 255;
    }

    ctx.putImageData(imageData, 0, 0);
}

function applyHighPassFilter() {
    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;

    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;

    // Convert to grayscale
    const gray = new Uint8ClampedArray(width * height);
    for (let i = 0; i < data.length; i += 4) {
        gray[i / 4] = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
    }

    // High-pass kernel (sharpening)
    const kernel = [
        -1, -1, -1,
        -1,  8, -1,
        -1, -1, -1
    ];

    const output = new Uint8ClampedArray(gray.length);

    // Apply convolution
    for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
            let sum = 0;
            for (let ky = -1; ky <= 1; ky++) {
                for (let kx = -1; kx <= 1; kx++) {
                    const px = x + kx;
                    const py = y + ky;
                    const pixelVal = gray[py * width + px];
                    const kernelVal = kernel[(ky + 1) * 3 + (kx + 1)];
                    sum += pixelVal * kernelVal;
                }
            }

            // Clamp the result between 0 and 255
            const idx = y * width + x;
            output[idx] = Math.min(255, Math.max(0, sum));
        }
    }

    // Copy result back to image data
    for (let i = 0; i < output.length; i++) {
        const val = output[i];
        const idx = i * 4;
        data[idx] = data[idx + 1] = data[idx + 2] = val;
        data[idx + 3] = 255; // full alpha
    }

    ctx.putImageData(imageData, 0, 0);
}


function adaptiveLuminanceSegmentation(blockSize = 15, offset = 10) {
    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;
    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;

    const gray = new Uint8ClampedArray(width * height);
    for (let i = 0; i < data.length; i += 4) {
        gray[i / 4] = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
    }

    // Build integral image
    const integral = new Float64Array((width + 1) * (height + 1));
    for (let y = 1; y <= height; y++) {
        for (let x = 1; x <= width; x++) {
            const idx = (y - 1) * width + (x - 1);
            const integralIdx = y * (width + 1) + x;
            integral[integralIdx] =
                gray[idx] +
                integral[(y - 1) * (width + 1) + x] +
                integral[y * (width + 1) + (x - 1)] -
                integral[(y - 1) * (width + 1) + (x - 1)];
        }
    }

    // Clamp helper to fit integral image indexing and avoid negative area
    function getSum(x1, y1, x2, y2) {
        x1 = Math.max(0, Math.min(width - 1, x1));
        y1 = Math.max(0, Math.min(height - 1, y1));
        x2 = Math.max(0, Math.min(width - 1, x2));
        y2 = Math.max(0, Math.min(height - 1, y2));

        if (x2 < x1 || y2 < y1) return 0;

        const A = integral[y1 * (width + 1) + x1];
        const B = integral[y1 * (width + 1) + (x2 + 1)];
        const C = integral[(y2 + 1) * (width + 1) + x1];
        const D = integral[(y2 + 1) * (width + 1) + (x2 + 1)];
        return D - B - C + A;
    }

    const result = new Uint8ClampedArray(data.length);

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const idx = y * width + x;

            const x1 = x - blockSize;
            const y1 = y - blockSize;
            const x2 = x + blockSize;
            const y2 = y + blockSize;

            const left = Math.max(0, x1);
            const top = Math.max(0, y1);
            const right = Math.min(width - 1, x2);
            const bottom = Math.min(height - 1, y2);

            const area = (right - left + 1) * (bottom - top + 1);

            const localMean = getSum(x1, y1, x2, y2) / area;
            const lum = gray[idx];

            const val = lum < localMean - offset ? 0 : 255;

            result[idx * 4] = result[idx * 4 + 1] = result[idx * 4 + 2] = val;
            result[idx * 4 + 3] = 255;
        }
    }

    const newImage = new ImageData(result, width, height);
    ctx.putImageData(newImage, 0, 0);
}

function adaptiveLuminanceMaskColor(blockSize = 15, offset = 10) {
    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;
    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;

    // Convert to grayscale
    const gray = new Uint8ClampedArray(width * height);
    for (let i = 0; i < data.length; i += 4) {
        gray[i / 4] = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
    }

    // Build integral image
    const integral = new Float64Array((width + 1) * (height + 1));
    for (let y = 1; y <= height; y++) {
        for (let x = 1; x <= width; x++) {
            const idx = (y - 1) * width + (x - 1);
            const integralIdx = y * (width + 1) + x;
            integral[integralIdx] =
                gray[idx] +
                integral[(y - 1) * (width + 1) + x] +
                integral[y * (width + 1) + (x - 1)] -
                integral[(y - 1) * (width + 1) + (x - 1)];
        }
    }

    // Helper to get sum over a region
    function getSum(x1, y1, x2, y2) {
        x1 = Math.max(0, Math.min(width - 1, x1));
        y1 = Math.max(0, Math.min(height - 1, y1));
        x2 = Math.max(0, Math.min(width - 1, x2));
        y2 = Math.max(0, Math.min(height - 1, y2));
        if (x2 < x1 || y2 < y1) return 0;

        const A = integral[y1 * (width + 1) + x1];
        const B = integral[y1 * (width + 1) + (x2 + 1)];
        const C = integral[(y2 + 1) * (width + 1) + x1];
        const D = integral[(y2 + 1) * (width + 1) + (x2 + 1)];
        return D - B - C + A;
    }

    const result = new Uint8ClampedArray(data.length);

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const idx = y * width + x;

            const x1 = x - blockSize;
            const y1 = y - blockSize;
            const x2 = x + blockSize;
            const y2 = y + blockSize;

            const left = Math.max(0, x1);
            const top = Math.max(0, y1);
            const right = Math.min(width - 1, x2);
            const bottom = Math.min(height - 1, y2);

            const area = (right - left + 1) * (bottom - top + 1);
            const localMean = getSum(x1, y1, x2, y2) / area;
            const lum = gray[idx];

            // ‚úÖ Inverted logic: keep dark regions
            const keep = lum < localMean - offset;
            const i = idx * 4;

            if (keep) {
                result[i] = data[i];         // R
                result[i + 1] = data[i + 1]; // G
                result[i + 2] = data[i + 2]; // B
                result[i + 3] = 255;         // Opaque
            } else {
                result[i] = 0;
                result[i + 1] = 0;
                result[i + 2] = 0;
                result[i + 3] = 0;           // Transparent
            }
        }
    }

    const newImage = new ImageData(result, width, height);
    ctx.clearRect(0, 0, width, height); // Clear canvas for transparency
    ctx.putImageData(newImage, 0, 0);
}

function adaptiveLuminanceMaskWithContours(blockSize = 15, offset = 10, minContourSize = 50) {
    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;
    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;

    // Convert to grayscale
    const gray = new Uint8ClampedArray(width * height);
    for (let i = 0; i < data.length; i += 4) {
        gray[i / 4] = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
    }

    // Build integral image for adaptive mean
    const integral = new Float64Array((width + 1) * (height + 1));
    for (let y = 1; y <= height; y++) {
        for (let x = 1; x <= width; x++) {
            const idx = (y - 1) * width + (x - 1);
            const integralIdx = y * (width + 1) + x;
            integral[integralIdx] =
                gray[idx] +
                integral[(y - 1) * (width + 1) + x] +
                integral[y * (width + 1) + (x - 1)] -
                integral[(y - 1) * (width + 1) + (x - 1)];
        }
    }

    // Helper to get sum over a region
    function getSum(x1, y1, x2, y2) {
        x1 = Math.max(0, Math.min(width - 1, x1));
        y1 = Math.max(0, Math.min(height - 1, y1));
        x2 = Math.max(0, Math.min(width - 1, x2));
        y2 = Math.max(0, Math.min(height - 1, y2));
        if (x2 < x1 || y2 < y1) return 0;

        const A = integral[y1 * (width + 1) + x1];
        const B = integral[y1 * (width + 1) + (x2 + 1)];
        const C = integral[(y2 + 1) * (width + 1) + x1];
        const D = integral[(y2 + 1) * (width + 1) + (x2 + 1)];
        return D - B - C + A;
    }

    // Compute Sobel edges (binary mask)
    function computeSobelEdges(gray, width, height, threshold = 100) {
        const edges = new Uint8ClampedArray(width * height);
        for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
                const idx = y * width + x;

                const gx =
                    -gray[(y - 1) * width + (x - 1)] + gray[(y - 1) * width + (x + 1)] +
                    -2 * gray[y * width + (x - 1)] + 2 * gray[y * width + (x + 1)] +
                    -gray[(y + 1) * width + (x - 1)] + gray[(y + 1) * width + (x + 1)];

                const gy =
                    -gray[(y - 1) * width + (x - 1)] - 2 * gray[(y - 1) * width + x] - gray[(y - 1) * width + (x + 1)] +
                    gray[(y + 1) * width + (x - 1)] + 2 * gray[(y + 1) * width + x] + gray[(y + 1) * width + (x + 1)];

                const mag = Math.sqrt(gx * gx + gy * gy);

                edges[idx] = mag > threshold ? 1 : 0;
            }
        }
        return edges;
    }

    // Find connected components (contours) in mask using DFS
    function findConnectedComponents(mask, width, height) {
        const labels = new Int32Array(width * height).fill(-1);
        let currentLabel = 0;
        const neighbors = [
            [-1, 0], [1, 0], [0, -1], [0, 1]
        ];

        function inBounds(x, y) {
            return x >= 0 && x < width && y >= 0 && y < height;
        }

        for (let i = 0; i < mask.length; i++) {
            if (mask[i] === 0 || labels[i] !== -1) continue;

            // BFS or DFS
            const stack = [i];
            labels[i] = currentLabel;
            while (stack.length) {
                const idx = stack.pop();
                const x = idx % width;
                const y = Math.floor(idx / width);

                for (const [dx, dy] of neighbors) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (!inBounds(nx, ny)) continue;
                    const nidx = ny * width + nx;
                    if (mask[nidx] === 1 && labels[nidx] === -1) {
                        labels[nidx] = currentLabel;
                        stack.push(nidx);
                    }
                }
            }

            currentLabel++;
        }

        return { labels, count: currentLabel };
    }

    // === Step 1: Create initial mask with adaptive luminance inverted logic + edges combined ===
    const initialMask = new Uint8ClampedArray(width * height);
    const edges = computeSobelEdges(gray, width, height, 100);

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const idx = y * width + x;

            const x1 = x - blockSize;
            const y1 = y - blockSize;
            const x2 = x + blockSize;
            const y2 = y + blockSize;

            const left = Math.max(0, x1);
            const top = Math.max(0, y1);
            const right = Math.min(width - 1, x2);
            const bottom = Math.min(height - 1, y2);

            const area = (right - left + 1) * (bottom - top + 1);
            const localMean = getSum(x1, y1, x2, y2) / area;
            const lum = gray[idx];

            // Inverted luminance threshold OR edge pixel
            initialMask[idx] = (lum < localMean - offset || edges[idx] === 1) ? 1 : 0;
        }
    }

    // === Step 2: Find contours (connected components) in initial mask ===
    const { labels, count } = findConnectedComponents(initialMask, width, height);

    // === Step 3: Calculate contour sizes ===
    const contourSizes = new Array(count).fill(0);
    for (let i = 0; i < labels.length; i++) {
        if (labels[i] >= 0) contourSizes[labels[i]]++;
    }

    // === Step 4: Create final mask ‚Äî keep pixels that belong to sufficiently large contours ===
    // This preserves small logos/shapes by keeping contours bigger than minContourSize
    const finalMask = new Uint8ClampedArray(width * height);
    for (let i = 0; i < labels.length; i++) {
        const label = labels[i];
        finalMask[i] = (label >= 0 && contourSizes[label] >= minContourSize) ? 1 : 0;
    }

    // === Step 5: Apply final mask to original color image ===
    const result = new Uint8ClampedArray(data.length);
    for (let i = 0; i < width * height; i++) {
        const pixelIndex = i * 4;
        if (finalMask[i] === 1) {
            // Keep original color
            result[pixelIndex] = data[pixelIndex];
            result[pixelIndex + 1] = data[pixelIndex + 1];
            result[pixelIndex + 2] = data[pixelIndex + 2];
            result[pixelIndex + 3] = 255; // opaque
        } else {
            // Transparent
            result[pixelIndex] = 0;
            result[pixelIndex + 1] = 0;
            result[pixelIndex + 2] = 0;
            result[pixelIndex + 3] = 0; // transparent
        }
    }

    // Render result back on canvas
    const newImage = new ImageData(result, width, height);
    ctx.clearRect(0, 0, width, height);
    ctx.putImageData(newImage, 0, 0);
}



function adaptiveLuminanceSegmentationWithCCL(blockSize = 15, offset = 10) {
    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;
    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;

    const gray = new Uint8ClampedArray(width * height);
    for (let i = 0; i < data.length; i += 4) {
        gray[i / 4] = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
    }

    // Integral image for adaptive thresholding
    const integral = new Float64Array((width + 1) * (height + 1));
    for (let y = 1; y <= height; y++) {
        for (let x = 1; x <= width; x++) {
            const idx = (y - 1) * width + (x - 1);
            const integralIdx = y * (width + 1) + x;
            integral[integralIdx] =
                gray[idx] +
                integral[(y - 1) * (width + 1) + x] +
                integral[y * (width + 1) + (x - 1)] -
                integral[(y - 1) * (width + 1) + (x - 1)];
        }
    }

    function getSum(x1, y1, x2, y2) {
        x1 = Math.max(0, Math.min(width - 1, x1));
        y1 = Math.max(0, Math.min(height - 1, y1));
        x2 = Math.max(0, Math.min(width - 1, x2));
        y2 = Math.max(0, Math.min(height - 1, y2));

        if (x2 < x1 || y2 < y1) return 0;

        const A = integral[y1 * (width + 1) + x1];
        const B = integral[y1 * (width + 1) + (x2 + 1)];
        const C = integral[(y2 + 1) * (width + 1) + x1];
        const D = integral[(y2 + 1) * (width + 1) + (x2 + 1)];
        return D - B - C + A;
    }

    // Global binarization for CCL
    const binary = new Uint8ClampedArray(width * height);
    const globalMean = gray.reduce((a, b) => a + b, 0) / gray.length;
    for (let i = 0; i < gray.length; i++) {
        binary[i] = gray[i] < globalMean ? 1 : 0;
    }

    // CCL
    const labels = new Int32Array(width * height);
    let label = 1;
    const parent = [];

    function find(x) {
        while (parent[x] !== x) {
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    function union(x, y) {
        parent[find(x)] = find(y);
    }

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const idx = y * width + x;
            if (binary[idx] === 0) continue;

            const neighbors = [];
            if (x > 0 && binary[idx - 1] === 1) neighbors.push(labels[idx - 1]);
            if (y > 0 && binary[idx - width] === 1) neighbors.push(labels[idx - width]);

            if (neighbors.length === 0) {
                labels[idx] = label;
                parent[label] = label;
                label++;
            } else {
                const minLabel = Math.min(...neighbors);
                labels[idx] = minLabel;
                for (const l of neighbors) {
                    if (l !== minLabel) union(l, minLabel);
                }
            }
        }
    }

    const finalLabels = new Int32Array(labels.length);
    for (let i = 0; i < labels.length; i++) {
        finalLabels[i] = labels[i] === 0 ? 0 : find(labels[i]);
    }

    // Components
    const components = new Map();
    for (let i = 0; i < finalLabels.length; i++) {
        const lbl = finalLabels[i];
        if (lbl === 0) continue;

        if (!components.has(lbl)) {
            components.set(lbl, { pixels: [] });
        }
        components.get(lbl).pixels.push(i);
    }

    // Identify photo-like components
    const photoMask = new Uint8ClampedArray(width * height);
    for (const [lbl, comp] of components.entries()) {
        const pixelCount = comp.pixels.length;

        // Skip small components
        if (pixelCount < 1500) continue;

        // Calculate grayscale variance
        let sum = 0, sumSq = 0;
        for (const idx of comp.pixels) {
            const val = gray[idx];
            sum += val;
            sumSq += val * val;
        }
        const mean = sum / pixelCount;
        const variance = (sumSq / pixelCount) - mean * mean;

        if (variance > 180) {
            for (const idx of comp.pixels) {
                photoMask[idx] = 1;
            }
        }
    }

    // Final adaptive thresholding, skipping detected photo regions
    const result = new Uint8ClampedArray(data.length);
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const idx = y * width + x;

            if (photoMask[idx]) {
                const g = gray[idx];
                result[idx * 4] = result[idx * 4 + 1] = result[idx * 4 + 2] = g;
                result[idx * 4 + 3] = 255;
                continue;
            }

            const x1 = x - blockSize;
            const y1 = y - blockSize;
            const x2 = x + blockSize;
            const y2 = y + blockSize;
            const left = Math.max(0, x1);
            const top = Math.max(0, y1);
            const right = Math.min(width - 1, x2);
            const bottom = Math.min(height - 1, y2);
            const area = (right - left + 1) * (bottom - top + 1);

            const localMean = getSum(x1, y1, x2, y2) / area;
            const lum = gray[idx];
            const val = lum < localMean - offset ? 0 : 255;

            result[idx * 4] = result[idx * 4 + 1] = result[idx * 4 + 2] = val;
            result[idx * 4 + 3] = 255;
        }
    }

    const newImage = new ImageData(result, width, height);
    ctx.putImageData(newImage, 0, 0);
}

function unsharpMasking(amount = 1.0, radius = 1.0, threshold = 10) {
    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;
    const imageData = ctx.getImageData(0, 0, width, height);
    const original = new Uint8ClampedArray(imageData.data); // copy of original data
    const blurred = gaussianBlur(original, width, height, radius);

    for (let i = 0; i < imageData.data.length; i += 4) {
        for (let c = 0; c < 3; c++) {
            const diff = original[i + c] - blurred[i + c];
            if (Math.abs(diff) > threshold) {
                let sharp = original[i + c] + amount * diff;
                sharp = Math.round(sharp);
                imageData.data[i + c] = Math.min(255, Math.max(0, sharp));
            } else {
                // No change if difference is below threshold
                imageData.data[i + c] = original[i + c];
            }
        }
        imageData.data[i + 3] = original[i + 3]; // preserve alpha
    }

    ctx.putImageData(imageData, 0, 0);
}


function laplacianEdgeAwareEnhancement({
    edgeStrength = 1.0,
    bilateralRadius = 3,
    sigmaSpatial = 3.0,
    sigmaRange = 30.0,
    adaptiveScaling = true,
    edgeSharpness = 0.1
} = {}) {
    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;
    const imageData = ctx.getImageData(0, 0, width, height);
    const original = new Uint8ClampedArray(imageData.data); // Copy original

    // 1. Precompute spatial Gaussian weights for bilateral filter
    const diameter = bilateralRadius * 2 + 1;
    const spatialWeights = new Float32Array(diameter * diameter);
    let idxWeight = 0;
    for (let dy = -bilateralRadius; dy <= bilateralRadius; dy++) {
        for (let dx = -bilateralRadius; dx <= bilateralRadius; dx++) {
            const dist2 = dx * dx + dy * dy;
            spatialWeights[idxWeight++] = Math.exp(-dist2 / (2 * sigmaSpatial * sigmaSpatial));
        }
    }

    // 2. Apply bilateral filter on RGB channels only (skip borders)
    const bilateral = new Uint8ClampedArray(original.length);
    bilateral.set(original); // Initialize edges directly (for border pixels)

    // Helper function: pixel index
    const idx = (x, y) => (y * width + x) * 4;

    for (let y = bilateralRadius; y < height - bilateralRadius; y++) {
        for (let x = bilateralRadius; x < width - bilateralRadius; x++) {
            const centerIdx = idx(x, y);

            for (let c = 0; c < 3; c++) {
                const centerVal = original[centerIdx + c];
                let sum = 0, norm = 0;
                let wIdx = 0;

                for (let dy = -bilateralRadius; dy <= bilateralRadius; dy++) {
                    for (let dx = -bilateralRadius; dx <= bilateralRadius; dx++) {
                        const neighborIdx = idx(x + dx, y + dy);
                        const neighborVal = original[neighborIdx + c];

                        // Compute range weight based on intensity difference
                        const diff = centerVal - neighborVal;
                        const rangeWeight = Math.exp(- (diff * diff) / (2 * sigmaRange * sigmaRange));

                        // Combined weight
                        const weight = spatialWeights[wIdx++] * rangeWeight;

                        sum += weight * neighborVal;
                        norm += weight;
                    }
                }
                bilateral[centerIdx + c] = norm > 0 ? sum / norm : centerVal;
            }
            bilateral[centerIdx + 3] = 255; // alpha stays opaque
        }
    }

    // 3. Compute Laplacian on bilateral filtered image
    const laplacianKernel = [
        0,  1,  0,
        1, -4,  1,
        0,  1,  0
    ];
    const laplacian = new Float32Array(original.length);

    for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
            const centerIdx = idx(x, y);

            for (let c = 0; c < 3; c++) {
                let sum = 0;
                let k = 0;
                for (let ky = -1; ky <= 1; ky++) {
                    for (let kx = -1; kx <= 1; kx++) {
                        const neighborIdx = idx(x + kx, y + ky);
                        sum += laplacianKernel[k++] * bilateral[neighborIdx + c];
                    }
                }
                laplacian[centerIdx + c] = sum;
            }
        }
    }

    // 4. Compute edge magnitude map & apply adaptive enhancement
    for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
            const centerIdx = idx(x, y);

            // Edge magnitude is mean absolute Laplacian across channels
            const edgeMag = (
                Math.abs(laplacian[centerIdx]) +
                Math.abs(laplacian[centerIdx + 1]) +
                Math.abs(laplacian[centerIdx + 2])
            ) / 3;

            let weight;
            if (adaptiveScaling) {
                // Smooth sigmoid-like scaling to avoid harsh thresholding
                weight = edgeStrength * (edgeMag / (edgeMag + edgeSharpness * 255));
            } else {
                weight = edgeMag > 20 ? edgeStrength : 0;
            }

            // Apply enhancement to original image
            for (let c = 0; c < 3; c++) {
                const enhanced = original[centerIdx + c] - weight * laplacian[centerIdx + c];
                imageData.data[centerIdx + c] = Math.min(255, Math.max(0, enhanced));
            }
            imageData.data[centerIdx + 3] = 255; // preserve alpha
        }
    }

    // For border pixels (1 px edges), copy original without modification
    for (let y = 0; y < height; y++) {
        for (let x of [0, width - 1]) {
            const i = idx(x, y);
            for (let c = 0; c < 4; c++) {
                imageData.data[i + c] = original[i + c];
            }
        }
    }
    for (let x = 0; x < width; x++) {
        for (let y of [0, height - 1]) {
            const i = idx(x, y);
            for (let c = 0; c < 4; c++) {
                imageData.data[i + c] = original[i + c];
            }
        }
    }

    ctx.putImageData(imageData, 0, 0);
}


function bilateralFilter(data, width, height, radius, sigmaSpatial, sigmaRange) {
    const output = new Uint8ClampedArray(data.length);
    const spatialWeights = [];

    for (let dy = -radius; dy <= radius; dy++) {
        for (let dx = -radius; dx <= radius; dx++) {
            const dist2 = dx * dx + dy * dy;
            spatialWeights.push(Math.exp(-dist2 / (2 * sigmaSpatial * sigmaSpatial)));
        }
    }

    const idx = (x, y) => (y * width + x) * 4;

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const centerIdx = idx(x, y);  // <-- Moved here inside the loop!

            for (let c = 0; c < 3; c++) {
                let sum = 0;
                let norm = 0;
                let i = 0;

                const centerVal = data[centerIdx + c];

                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx < 0 || ny < 0 || nx >= width || ny >= height) {
                            i++;
                            continue;
                        }

                        const nIdx = idx(nx, ny);
                        const neighborVal = data[nIdx + c];
                        const rangeWeight = Math.exp(
                            -Math.pow(centerVal - neighborVal, 2) / (2 * sigmaRange * sigmaRange)
                        );
                        const weight = spatialWeights[i] * rangeWeight;

                        sum += weight * neighborVal;
                        norm += weight;
                        i++;
                    }
                }

                output[centerIdx + c] = norm > 0 ? sum / norm : centerVal;
            }
            output[centerIdx + 3] = 255; // alpha
        }
    }

    return output;
}


function computeLaplacian(data, width, height) {
    const kernel = [
        0,  1,  0,
        1, -4,  1,
        0,  1,  0
    ];
    const output = new Float32Array(data.length);
    const idx = (x, y) => (y * width + x) * 4;

    for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
            for (let c = 0; c < 3; c++) {
                let sum = 0;
                for (let ky = -1; ky <= 1; ky++) {
                    for (let kx = -1; kx <= 1; kx++) {
                        const weight = kernel[(ky + 1) * 3 + (kx + 1)];
                        const srcIdx = idx(x + kx, y + ky);
                        sum += weight * data[srcIdx + c];
                    }
                }
                output[idx(x, y) + c] = sum;
            }
        }
    }

    return output;
}


function edgeAwareAdaptiveThresholding(radius = 1.0, blockSize = 15, C = 10) {
    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;

    const imageData = ctx.getImageData(0, 0, width, height);
    const original = new Uint8ClampedArray(imageData.data);
    const blurred = gaussianBlur(original, width, height, radius);

    const pixelCount = width * height;
    const gray = new Float32Array(pixelCount);
    const grayBlur = new Float32Array(pixelCount);
    const edgeMagnitude = new Float32Array(pixelCount);

    // Convert both original and blurred to grayscale
    for (let i = 0; i < pixelCount; i++) {
        const r1 = original[i * 4],     g1 = original[i * 4 + 1],     b1 = original[i * 4 + 2];
        const r2 = blurred[i * 4],      g2 = blurred[i * 4 + 1],      b2 = blurred[i * 4 + 2];
        const gray1 = 0.299 * r1 + 0.587 * g1 + 0.114 * b1;
        const gray2 = 0.299 * r2 + 0.587 * g2 + 0.114 * b2;

        gray[i] = gray1;
        grayBlur[i] = gray2;
        edgeMagnitude[i] = Math.abs(gray1 - gray2); // High-pass
    }
    
    // Normalize edgeMagnitude to [0, 1] without using spread
const maxEdge = edgeMagnitude.reduce((max, val) => Math.max(max, val), -Infinity) || 1e-5;

for (let i = 0; i < edgeMagnitude.length; i++) {
    edgeMagnitude[i] /= maxEdge;
}


    // Build integral image of grayscale for fast local mean computation
    const integral = new Float32Array(pixelCount);

    for (let y = 0; y < height; y++) {
        let rowSum = 0;
        for (let x = 0; x < width; x++) {
            const idx = y * width + x;
            rowSum += gray[idx];
            integral[idx] = rowSum + (y > 0 ? integral[(y - 1) * width + x] : 0);
        }
    }

    // Helper to get sum from integral image in a region
    function getRegionSum(x0, y0, x1, y1) {
        x0 = Math.max(0, x0);
        y0 = Math.max(0, y0);
        x1 = Math.min(width - 1, x1);
        y1 = Math.min(height - 1, y1);

        const A = integral[y0 * width + x0];
        const B = integral[y0 * width + x1];
        const C = integral[y1 * width + x0];
        const D = integral[y1 * width + x1];

        return D - B - C + A;
    }

    const halfBlock = Math.floor(blockSize / 2);

    // Apply adaptive threshold
    for (let y = 0; y < height; y++) {
        const y0 = y - halfBlock;
        const y1 = y + halfBlock;

        for (let x = 0; x < width; x++) {
            const x0 = x - halfBlock;
            const x1 = x + halfBlock;

            const idx = y * width + x;

            // Get local mean using integral image
            const regionWidth = x1 - x0 + 1;
            const regionHeight = y1 - y0 + 1;
            const count = regionWidth * regionHeight;

            const regionSum = getRegionSum(x0, y0, x1, y1);
            const localMean = regionSum / count;

            const edgeBoost = edgeMagnitude[idx] * C;
            const threshold = localMean - (C - edgeBoost);

            const value = gray[idx] >= threshold ? 255 : 0;

            const offset = idx * 4;
            imageData.data[offset] = imageData.data[offset + 1] = imageData.data[offset + 2] = value;
            imageData.data[offset + 3] = 255;
        }
    }

    ctx.putImageData(imageData, 0, 0);
}


function gaussianBlur(data, width, height, radius) {
    const kernel = createGaussianKernel(radius);
    const temp = new Uint8ClampedArray(data.length);
    const output = new Uint8ClampedArray(data.length);

    // Horizontal pass
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            for (let c = 0; c < 3; c++) {
                let acc = 0, weightSum = 0;
                for (let k = -radius; k <= radius; k++) {
                    const ix = Math.min(width - 1, Math.max(0, x + k));
                    const idx = 4 * (y * width + ix);
                    acc += data[idx + c] * kernel[k + radius];
                    weightSum += kernel[k + radius];
                }
                const idx = 4 * (y * width + x);
                temp[idx + c] = acc / weightSum;
            }
            temp[4 * (y * width + x) + 3] = 255;
        }
    }

    // Vertical pass
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            for (let c = 0; c < 3; c++) {
                let acc = 0, weightSum = 0;
                for (let k = -radius; k <= radius; k++) {
                    const iy = Math.min(height - 1, Math.max(0, y + k));
                    const idx = 4 * (iy * width + x);
                    acc += temp[idx + c] * kernel[k + radius];
                    weightSum += kernel[k + radius];
                }
                const idx = 4 * (y * width + x);
                output[idx + c] = acc / weightSum;
            }
            output[4 * (y * width + x) + 3] = 255;
        }
    }

    return output;
}

function createGaussianKernel(radius) {
    const kernelSize = 2 * radius + 1;
    const sigma = radius / 2;
    const kernel = new Float32Array(kernelSize);
    let sum = 0;

    for (let i = 0; i < kernelSize; i++) {
        const x = i - radius;
        kernel[i] = Math.exp(-(x * x) / (2 * sigma * sigma));
        sum += kernel[i];
    }

    // Normalize
    for (let i = 0; i < kernel.length; i++) {
        kernel[i] /= sum;
    }

    return kernel;
}

//function adaptiveHistogramEqualization(tileSize = 100, clipLimit = 35) {
function adaptiveHistogramEqualization(tileSize = 130, clipLimit = 50) {
    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;

    const width = canvas.width;
    const height = canvas.height;

    // Create Lightness matrix (HSL)
    const lightness = new Array(height).fill(0).map(() => new Array(width).fill(0));
    const hslData = new Array(height).fill(0).map(() => new Array(width).fill([0, 0, 0]));

    function rgbToHsl(r, g, b) {
        r /= 255; g /= 255; b /= 255;
        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h = 0, s = 0, l = (max + min) / 2;

        if (max !== min) {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r: h = ((g - b) / d + (g < b ? 6 : 0)); break;
                case g: h = ((b - r) / d + 2); break;
                case b: h = ((r - g) / d + 4); break;
            }
            h /= 6;
        }
        return [h, s, l];
    }

    function hslToRgb(h, s, l) {
        let r, g, b;

        if (s === 0) {
            r = g = b = l; // achromatic
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1 / 6) return p + (q - p) * 6 * t;
                if (t < 1 / 2) return q;
                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                return p;
            };
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
        }

        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    // Convert image to HSL and extract Lightness
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const i = (y * width + x) * 4;
            const [h, s, l] = rgbToHsl(data[i], data[i + 1], data[i + 2]);
            lightness[y][x] = Math.round(l * 255);
            hslData[y][x] = [h, s, l]; // store for later
        }
    }

    // CLAHE Functions
    function clipHistogram(hist, limit) {
        let excess = 0;
        for (let i = 0; i < 256; i++) {
            if (hist[i] > limit) {
                excess += hist[i] - limit;
                hist[i] = limit;
            }
        }
        const redistribute = excess / 256;
        for (let i = 0; i < 256; i++) {
            hist[i] += redistribute;
        }
        return hist;
    }

    function equalizeTileCLAHE(tile, clipLimit) {
        const hist = new Array(256).fill(0);
        for (let y = 0; y < tile.length; y++) {
            for (let x = 0; x < tile[0].length; x++) {
                hist[tile[y][x]]++;
            }
        }
        clipHistogram(hist, clipLimit);
        const cdf = hist.slice();
        for (let i = 1; i < 256; i++) {
            cdf[i] += cdf[i - 1];
        }
        const cdfMin = cdf.find(v => v > 0);
        const total = cdf[255];
        const lut = cdf.map(v => Math.round(((v - cdfMin) / (total - cdfMin)) * 255));
        return tile.map(row => row.map(val => lut[val]));
    }

    // Apply CLAHE tile-wise
    for (let tileY = 0; tileY < height; tileY += tileSize) {
        for (let tileX = 0; tileX < width; tileX += tileSize) {
            const tile = [];
            for (let y = 0; y < tileSize && (tileY + y) < height; y++) {
                tile[y] = [];
                for (let x = 0; x < tileSize && (tileX + x) < width; x++) {
                    tile[y][x] = lightness[tileY + y][tileX + x];
                }
            }

            const equalized = equalizeTileCLAHE(tile, clipLimit);

            for (let y = 0; y < equalized.length; y++) {
                for (let x = 0; x < equalized[0].length; x++) {
                    const newL = equalized[y][x] / 255;
                    const [h, s] = hslData[tileY + y][tileX + x];
                    const [r, g, b] = hslToRgb(h, s, newL);
                    const idx = ((tileY + y) * width + (tileX + x)) * 4;
                    data[idx] = r;
                    data[idx + 1] = g;
                    data[idx + 2] = b;
                }
            }
        }
    }

    ctx.putImageData(imageData, 0, 0);
}

function adaptiveHistogramEqualizationReinhard(tileSize = 100, baseClipLimit = 35, useToneCurve = true) {
    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;

    const width = canvas.width;
    const height = canvas.height;

    const lightness = new Array(height).fill(0).map(() => new Array(width).fill(0));
    const hslData = new Array(height).fill(0).map(() => new Array(width).fill([0, 0, 0]));

    function rgbToHsl(r, g, b) {
        r /= 255; g /= 255; b /= 255;
        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h = 0, s = 0, l = (max + min) / 2;

        if (max !== min) {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        return [h, s, l];
    }

    function hslToRgb(h, s, l) {
        let r, g, b;
        if (s === 0) {
            r = g = b = l;
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1 / 6) return p + (q - p) * 6 * t;
                if (t < 1 / 2) return q;
                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                return p;
            };
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
        }
        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    function clipHistogram(hist, limit) {
        let excess = 0;
        for (let i = 0; i < 256; i++) {
            if (hist[i] > limit) {
                excess += hist[i] - limit;
                hist[i] = limit;
            }
        }
        const redistribute = excess / 256;
        for (let i = 0; i < 256; i++) {
            hist[i] += redistribute;
        }
        return hist;
    }

    function equalizeTileCLAHE(tile, clipLimit) {
        const hist = new Array(256).fill(0);
        for (let y = 0; y < tile.length; y++) {
            for (let x = 0; x < tile[0].length; x++) {
                hist[tile[y][x]]++;
            }
        }
        clipHistogram(hist, clipLimit);
        const cdf = hist.slice();
        for (let i = 1; i < 256; i++) {
            cdf[i] += cdf[i - 1];
        }
        const cdfMin = cdf.find(v => v > 0);
        const total = cdf[255];
        const lut = cdf.map(v => Math.round(((v - cdfMin) / (total - cdfMin)) * 255));
        return tile.map(row => row.map(val => lut[val]));
    }

    function computeLocalContrast(tile) {
        let min = 255, max = 0;
        for (const row of tile) {
            for (const val of row) {
                if (val < min) min = val;
                if (val > max) max = val;
            }
        }
        return max - min;
    }

    function applyToneCurve(l) {
        const x = l / 255;
        const y = 0.5 * (Math.sin(Math.PI * (x - 0.5)) + 1); // S-curve
        return Math.round(y * 255);
    }

    // Convert image to HSL and extract Lightness
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const i = (y * width + x) * 4;
            const [h, s, l] = rgbToHsl(data[i], data[i + 1], data[i + 2]);
            lightness[y][x] = Math.round(l * 255);
            hslData[y][x] = [h, s, l];
        }
    }

    // Process tiles with adaptive CLAHE
    for (let tileY = 0; tileY < height; tileY += tileSize) {
        for (let tileX = 0; tileX < width; tileX += tileSize) {
            const tile = [];
            for (let y = 0; y < tileSize && (tileY + y) < height; y++) {
                tile[y] = [];
                for (let x = 0; x < tileSize && (tileX + x) < width; x++) {
                    tile[y][x] = lightness[tileY + y][tileX + x];
                }
            }

            const contrast = computeLocalContrast(tile);
            const adaptiveClip = Math.max(baseClipLimit * (contrast / 128), 5);
            const equalized = equalizeTileCLAHE(tile, adaptiveClip);

            for (let y = 0; y < equalized.length; y++) {
                for (let x = 0; x < equalized[0].length; x++) {
                    let newL = equalized[y][x];
                    if (useToneCurve) {
                        newL = applyToneCurve(newL);
                    }
                    newL /= 255;
                    const [h, s] = hslData[tileY + y][tileX + x];
                    const [r, g, b] = hslToRgb(h, s, newL);
                    const idx = ((tileY + y) * width + (tileX + x)) * 4;
                    data[idx] = r;
                    data[idx + 1] = g;
                    data[idx + 2] = b;
                }
            }
        }
    }

    ctx.putImageData(imageData, 0, 0);
}


function dualGammaCLAHE(tileSize = 64, clipLimit = 40, gammaLow = 0.6, gammaHigh = 1.5) {
    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");
    const { width, height } = canvas;
    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;

    const lightness = Array.from({ length: height }, () => new Array(width));
    const hslData = Array.from({ length: height }, () => new Array(width));

    function rgbToHsl(r, g, b) {
        r /= 255; g /= 255; b /= 255;
        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h = 0, s = 0, l = (max + min) / 2;
        if (max !== min) {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        return [h, s, l];
    }

    function hslToRgb(h, s, l) {
        const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        };
        let r, g, b;
        if (s === 0) r = g = b = l;
        else {
            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            const p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
        }
        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    // Extract lightness and cache HSL
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const idx = (y * width + x) * 4;
            const [h, s, l] = rgbToHsl(data[idx], data[idx + 1], data[idx + 2]);
            hslData[y][x] = [h, s];
            lightness[y][x] = Math.round(l * 255);
        }
    }

    function clipHistogram(hist, limit) {
        let excess = 0;
        for (let i = 0; i < 256; i++) {
            if (hist[i] > limit) {
                excess += hist[i] - limit;
                hist[i] = limit;
            }
        }
        const increment = excess / 256;
        for (let i = 0; i < 256; i++) {
            hist[i] += increment;
        }
        return hist;
    }

    function computeCDF(tile, clipLimit) {
        const hist = new Array(256).fill(0);
        for (let y = 0; y < tile.length; y++) {
            for (let x = 0; x < tile[0].length; x++) {
                hist[tile[y][x]]++;
            }
        }
        clipHistogram(hist, clipLimit);
        const cdf = hist.slice();
        for (let i = 1; i < 256; i++) cdf[i] += cdf[i - 1];
        const cdfMin = cdf.find(v => v > 0);
        const total = cdf[255];
        const lut = cdf.map(v => Math.round(((v - cdfMin) / (total - cdfMin)) * 255));
        return lut;
    }

    function gammaCorrect(lut, gamma) {
        const corrected = new Array(256);
        for (let i = 0; i < 256; i++) {
            const g = Math.pow(i / 255, gamma) * 255;
            corrected[i] = Math.min(255, Math.max(0, Math.round(g)));
        }
        return corrected.map(i => lut[i]);
    }

    const tilesX = Math.ceil(width / tileSize);
    const tilesY = Math.ceil(height / tileSize);
    const luts = Array.from({ length: tilesY }, () => new Array(tilesX));

    for (let ty = 0; ty < tilesY; ty++) {
        for (let tx = 0; tx < tilesX; tx++) {
            const tile = [];
            for (let y = 0; y < tileSize && (ty * tileSize + y) < height; y++) {
                tile[y] = [];
                for (let x = 0; x < tileSize && (tx * tileSize + x) < width; x++) {
                    tile[y][x] = lightness[ty * tileSize + y][tx * tileSize + x];
                }
            }
            const lut = computeCDF(tile, clipLimit);
            const low = gammaCorrect(lut, gammaLow);
            const high = gammaCorrect(lut, gammaHigh);
            luts[ty][tx] = { low, high };
        }
    }

    for (let y = 0; y < height; y++) {
        const ty = Math.floor(y / tileSize);
        const dy = (y % tileSize) / tileSize;
        for (let x = 0; x < width; x++) {
            const tx = Math.floor(x / tileSize);
            const dx = (x % tileSize) / tileSize;

            const l = lightness[y][x];
            const blendRatio = l / 255;

            function getLut(type, i, j) {
                const tY = Math.min(Math.max(j, 0), tilesY - 1);
                const tX = Math.min(Math.max(i, 0), tilesX - 1);
                return luts[tY][tX][type][l];
            }

            const ll = getLut("low", tx, ty);
            const lr = getLut("low", tx + 1, ty);
            const ul = getLut("low", tx, ty + 1);
            const ur = getLut("low", tx + 1, ty + 1);
            const lowVal = (1 - dx) * (1 - dy) * ll + dx * (1 - dy) * lr + (1 - dx) * dy * ul + dx * dy * ur;

            const hl = getLut("high", tx, ty);
            const hr = getLut("high", tx + 1, ty);
            const hu = getLut("high", tx, ty + 1);
            const hd = getLut("high", tx + 1, ty + 1);
            const highVal = (1 - dx) * (1 - dy) * hl + dx * (1 - dy) * hr + (1 - dx) * dy * hu + dx * dy * hd;

            // üîÑ Blend gamma-corrected values based on original lightness
            const finalL = Math.round((1 - blendRatio) * lowVal + blendRatio * highVal);
            const normL = Math.min(1, Math.max(0, finalL / 255));

            const [h, s] = hslData[y][x];
            const [r, g, b] = hslToRgb(h, s, normL);

            const idx = (y * width + x) * 4;
            data[idx] = r;
            data[idx + 1] = g;
            data[idx + 2] = b;
        }
    }

    ctx.putImageData(imageData, 0, 0);
}


document.querySelector('#textlayerdisplay').addEventListener("click", function(){
document.querySelectorAll('.text-layer').forEach(function(e){
    e.style.display = e.style.display === "none" ? "block" : "none";
});

})

function openWhatsApp() {
  const phoneNumber = prompt("Enter the phone number (with country code, no + sign):");

  if (phoneNumber) {
    const message = encodeURIComponent("Hello, I want to chat!"); // Optional pre-filled message
    const whatsappUrl = `https://wa.me/${phoneNumber}?text=${message}`;
    
    window.open(whatsappUrl, '_blank'); // Opens in a new tab
  } else {
    alert("Please enter a valid phone number.");
  }
}

document.getElementById('ManualdoublesideWithBlanks').addEventListener('click', async () => {
  const combinedPdfDoc = await PDFLib.PDFDocument.create();

  const A4_WIDTH = 595.28;
  const A4_HEIGHT = 841.89;

  for (const fileObj of fileListPdf) {
    const file = fileObj.file;

    if (file.type === 'application/pdf') {
      const pdfBytes = await file.arrayBuffer();
      const existingPdf = await PDFLib.PDFDocument.load(pdfBytes);
      let pageCount = existingPdf.getPageCount();

      // Copy all pages into combined PDF
      const copiedPages = await combinedPdfDoc.copyPages(existingPdf, existingPdf.getPageIndices());
      copiedPages.forEach(page => combinedPdfDoc.addPage(page));

      // If page count is odd, add a blank page
      if (pageCount % 2 === 1) {
        combinedPdfDoc.addPage([A4_WIDTH, A4_HEIGHT]);
      }
    }
  }

  // After all PDFs combined and blank pages added:
  const totalPages = combinedPdfDoc.getPageCount();
  const pageIndices = [...Array(totalPages).keys()]; // [0, 1, 2, ..., totalPages - 1]

  const oddIndices = pageIndices.filter(i => i % 2 === 0);
  const evenIndices = pageIndices.filter(i => i % 2 === 1).reverse();

  // Create separate docs for odd and even
  const oddPdfDoc = await PDFLib.PDFDocument.create();
  const evenPdfDoc = await PDFLib.PDFDocument.create();

  const copiedOddPages = await oddPdfDoc.copyPages(combinedPdfDoc, oddIndices);
  copiedOddPages.forEach(page => oddPdfDoc.addPage(page));

  const copiedEvenPages = await evenPdfDoc.copyPages(combinedPdfDoc, evenIndices);
  copiedEvenPages.forEach(page => evenPdfDoc.addPage(page));

  // Download odd pages
  if (oddPdfDoc.getPageCount() > 0) {
    const oddBytes = await oddPdfDoc.save();
    const oddBlob = new Blob([oddBytes], { type: 'application/pdf' });
    const oddLink = document.createElement('a');
    oddLink.href = URL.createObjectURL(oddBlob);
    oddLink.download = 'odd_pages_with_blanks.pdf';
    oddLink.click();
  }

  // Download even pages
  if (evenPdfDoc.getPageCount() > 0) {
    const evenBytes = await evenPdfDoc.save();
    const evenBlob = new Blob([evenBytes], { type: 'application/pdf' });
    const evenLink = document.createElement('a');
    evenLink.href = URL.createObjectURL(evenBlob);
    evenLink.download = 'even_pages_reversed.pdf';
    evenLink.click();
  }
});


document.getElementById('ManualBookletWithBlanks').addEventListener('click', async () => {
  const A4_WIDTH = 595.28;
  const A4_HEIGHT = 841.89;

  const combinedPdfDoc = await PDFLib.PDFDocument.create();

  // 1. Combine all PDFs and add blank page if needed
  for (const fileObj of fileListPdf) {
    const file = fileObj.file;
    if (file.type === 'application/pdf') {
      const pdfBytes = await file.arrayBuffer();
      const loadedPdf = await PDFLib.PDFDocument.load(pdfBytes);
      const copiedPages = await combinedPdfDoc.copyPages(loadedPdf, loadedPdf.getPageIndices());
      copiedPages.forEach(p => combinedPdfDoc.addPage(p));

      // Add blank page if original PDF has odd number of pages
      if (loadedPdf.getPageCount() % 2 === 1) {
        combinedPdfDoc.addPage();
      }
    }
  }

  // 2. Pad to multiple of 4
  while (combinedPdfDoc.getPageCount() % 4 !== 0) {
    combinedPdfDoc.addPage();
  }

  const totalPages = combinedPdfDoc.getPageCount();
  const pageOrder = [];

  // 3. Build booklet page order: [last, first], [second, second-last], ...
  let left = 0;
  let right = totalPages - 1;

  while (left < right) {
    pageOrder.push([right, left]);   // front of sheet
    left++;
    right--;

    if (left < right) {
      pageOrder.push([left, right]); // back of sheet
      left++;
      right--;
    }
  }

  // 4. Create final booklet PDF
  const bookletPdf = await PDFLib.PDFDocument.create();

  for (const pair of pageOrder) {
    const [index1, index2] = pair;

    if (
      index1 >= 0 && index1 < totalPages &&
      index2 >= 0 && index2 < totalPages &&
      index1 !== index2
    ) {
      const copied = await bookletPdf.copyPages(combinedPdfDoc, [index1, index2]);
      const [page1, page2] = copied;

      const sheet = bookletPdf.addPage([A4_HEIGHT, A4_WIDTH]); // A4 Landscape

      // Left: page1
      sheet.drawPage(page1, {
        x: 0,
        y: 0,
        width: A4_WIDTH,
        height: A4_HEIGHT,
      });

      // Right: page2
      sheet.drawPage(page2, {
        x: A4_WIDTH,
        y: 0,
        width: A4_WIDTH,
        height: A4_HEIGHT,
      });
    }
  }

  // 5. Download the final booklet
  const finalBytes = await bookletPdf.save();
  const blob = new Blob([finalBytes], { type: 'application/pdf' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = 'booklet.pdf';
  link.click();
});


document.querySelector('#centercontent').addEventListener("click", function() {
  const parent = document.querySelector('#array').parentElement;
  
  // Toggle between empty and "0 auto"
  if (parent.style.margin === "") {
    parent.style.margin = "0 auto"; // center horizontally    
  } else {
    parent.style.margin = ""; // reset to default
  }
});

document.querySelector('#displayblock').addEventListener("click", function() {
  document.querySelectorAll('#array table td').forEach(function(e) {
    if (e.style.display === "") {
      e.style.display = "block";
    } else {
      e.style.display = "";
    }
  });
});


async function generatePortraitPDF() {
    const { PDFDocument } = PDFLib;

    const pdfDoc = await PDFDocument.create();

    const pageWidth = 595;  // A4 Portrait width (points)
    const pageHeight = 842; // A4 Portrait height (points)

    const cols = 2;
    const rows = 4;
    const imagesPerPage = cols * rows;

    const cellWidth = pageWidth / cols;
    const cellHeight = pageHeight / rows;
    const padding = 10;

    const images = Array.from(document.querySelectorAll("img"));

    for (let i = 0; i < images.length; i += imagesPerPage) {
      const page = pdfDoc.addPage([pageWidth, pageHeight]);
      const chunk = images.slice(i, i + imagesPerPage);

      for (let j = 0; j < chunk.length; j++) {
        const img = chunk[j];
        const base64 = img.src;

        const imgBytes = await fetch(base64).then(res => res.arrayBuffer());

        const embeddedImg = base64.startsWith("data:image/png")
          ? await pdfDoc.embedPng(imgBytes)
          : await pdfDoc.embedJpg(imgBytes);

        // Scale image to fit within the cell with padding
        const scale = Math.min(
          (cellWidth - padding * 2) / embeddedImg.width,
          (cellHeight - padding * 2) / embeddedImg.height
        );

        const drawWidth = embeddedImg.width * scale;
        const drawHeight = embeddedImg.height * scale;

        const col = j % cols;
        const row = Math.floor(j / cols);

        const x = col * cellWidth + (cellWidth - drawWidth) / 2;
        const y = pageHeight - ((row + 1) * cellHeight) + (cellHeight - drawHeight) / 2;

        page.drawImage(embeddedImg, {
          x,
          y,
          width: drawWidth,
          height: drawHeight,
        });
      }
    }

    const pdfBytes = await pdfDoc.save();
    const blob = new Blob([pdfBytes], { type: 'application/pdf' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = "portrait_id_cards.pdf";
    a.click();
  }

  document.getElementById('openBillLink').addEventListener('click', function (e) {
    e.preventDefault(); // Prevent normal <a> behavior

    const refno = document.getElementById('refno').value.trim();

    if (!refno) {
      alert('Please enter a reference number.');
      return;
    }

    // Create a form dynamically
    const form = document.createElement('form');
    form.method = 'POST';
    form.action = `https://bill.pitc.com.pk/gbill.aspx?refno=${encodeURIComponent(refno)}`;
    form.target = '_blank'; // Open in a new tab

    // Add any POST parameters if needed (optional, since refno is already in URL)

    // Add to body and submit
    document.body.appendChild(form);
    form.submit();

    // Clean up
    document.body.removeChild(form);
  });

function gradientShadowRemovalWithGuidedFilter(canvas = document.querySelector("canvas")) {
  if (!canvas) {
    console.error("Canvas element not found.");
    return;
  }

  const ctx = canvas.getContext("2d");
  if (!ctx) {
    console.error("2D context not available.");
    return;
  }

  const width = canvas.width;
  const height = canvas.height;
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;

  // Convert RGB imageData to grayscale luminance (0..1)
  function rgbToGray(data) {
    const gray = new Float32Array(data.length / 4);
    for (let i = 0; i < gray.length; i++) {
      const r = data[i * 4];
      const g = data[i * 4 + 1];
      const b = data[i * 4 + 2];
      // luminance with Rec.709 weights
      gray[i] = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;
    }
    return gray;
  }

  // Box filter using integral image for fast mean computation
  function boxFilter(img, w, h, r) {
    const result = new Float32Array(img.length);
    const integral = new Float32Array((w + 1) * (h + 1));

    for (let y = 0; y <= h; y++) {
      for (let x = 0; x <= w; x++) {
        const idx = y * (w + 1) + x;
        if (x === 0 || y === 0) {
          integral[idx] = 0;
        } else {
          integral[idx] =
            img[(y - 1) * w + (x - 1)] +
            integral[idx - 1] +
            integral[idx - (w + 1)] -
            integral[idx - (w + 2)];
        }
      }
    }

    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const x1 = Math.max(x - r, 0);
        const x2 = Math.min(x + r, w - 1);
        const y1 = Math.max(y - r, 0);
        const y2 = Math.min(y + r, h - 1);

        const count = (x2 - x1 + 1) * (y2 - y1 + 1);

        const A = integral[y1 * (w + 1) + x1];
        const B = integral[y1 * (w + 1) + (x2 + 1)];
        const C = integral[(y2 + 1) * (w + 1) + x1];
        const D = integral[(y2 + 1) * (w + 1) + (x2 + 1)];

        result[y * w + x] = (D - B - C + A) / count;
      }
    }

    return result;
  }

  // Guided filter for grayscale image
  function guidedFilter(I, p, w, h, r, eps) {
    const N = boxFilter(new Float32Array(w * h).fill(1), w, h, r);

    const mean_I = boxFilter(I, w, h, r);
    const mean_p = boxFilter(p, w, h, r);

    const mean_Ip = boxFilter(
      Float32Array.from(I.map((v, i) => v * p[i])),
      w,
      h,
      r
    );

    const cov_Ip = new Float32Array(w * h);
    for (let i = 0; i < w * h; i++) {
      cov_Ip[i] = mean_Ip[i] - mean_I[i] * mean_p[i];
    }

    const mean_II = boxFilter(Float32Array.from(I.map((v) => v * v)), w, h, r);

    const var_I = new Float32Array(w * h);
    for (let i = 0; i < w * h; i++) {
      var_I[i] = mean_II[i] - mean_I[i] * mean_I[i];
    }

    const a = new Float32Array(w * h);
    const b = new Float32Array(w * h);
    for (let i = 0; i < w * h; i++) {
      a[i] = cov_Ip[i] / (var_I[i] + eps);
      b[i] = mean_p[i] - a[i] * mean_I[i];
    }

    const mean_a = boxFilter(a, w, h, r);
    const mean_b = boxFilter(b, w, h, r);

    const q = new Float32Array(w * h);
    for (let i = 0; i < w * h; i++) {
      q[i] = mean_a[i] * I[i] + mean_b[i];
    }

    return q;
  }

  // Apply illumination correction: multiply original color channels by 1 / illumination
  function applyIlluminationCorrection(data, illumination) {
    const corrected = new Uint8ClampedArray(data.length);
    for (let i = 0; i < illumination.length; i++) {
      const I = illumination[i];
      const eps = 1e-4;
      const ratio = I > eps ? Math.min(1.0 / I, 5) : 1.0;

      corrected[i * 4] = Math.min(data[i * 4] * ratio, 255);
      corrected[i * 4 + 1] = Math.min(data[i * 4 + 1] * ratio, 255);
      corrected[i * 4 + 2] = Math.min(data[i * 4 + 2] * ratio, 255);
      corrected[i * 4 + 3] = data[i * 4 + 3];
    }
    return corrected;
  }

  // Main process:
  // 1. Grayscale conversion for illumination estimation
  const gray = rgbToGray(data);

  // 2. Guided filter parameters: radius & epsilon ‚Äî adjust as needed
  const radius = 15;
  const epsilon = 0.01;

  // 3. Estimate illumination with guided filter (self-guided)
  const illumination = guidedFilter(gray, gray, width, height, radius, epsilon);

  // 4. Apply illumination correction for shadow removal
  const corrected = applyIlluminationCorrection(data, illumination);

  // 5. Write back corrected pixels to canvas
  for (let i = 0; i < data.length; i++) {
    data[i] = corrected[i];
  }

  ctx.putImageData(imageData, 0, 0);
}

function intelligentEdgeAwareThresholding(radius = 1.0, baseBlockSize = 15, C = 10) {
    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;

    const imageData = ctx.getImageData(0, 0, width, height);
    const original = new Uint8ClampedArray(imageData.data);
    const blurred = gaussianBlur(original, width, height, radius); // You must implement or import this

    const pixelCount = width * height;
    const gray = new Float32Array(pixelCount);
    const grayBlur = new Float32Array(pixelCount);
    const edgeMagnitude = new Float32Array(pixelCount);

    // Convert to grayscale & compute high-pass edges
    for (let i = 0; i < pixelCount; i++) {
        const r1 = original[i * 4], g1 = original[i * 4 + 1], b1 = original[i * 4 + 2];
        const r2 = blurred[i * 4], g2 = blurred[i * 4 + 1], b2 = blurred[i * 4 + 2];

        const gray1 = 0.299 * r1 + 0.587 * g1 + 0.114 * b1;
        const gray2 = 0.299 * r2 + 0.587 * g2 + 0.114 * b2;

        gray[i] = gray1;
        grayBlur[i] = gray2;
        edgeMagnitude[i] = Math.abs(gray1 - gray2); // simple high-pass
    }

    // Normalize edgeMagnitude to [0, 1]
    const maxEdge = edgeMagnitude.reduce((max, val) => Math.max(max, val), -Infinity) || 1e-5;
    for (let i = 0; i < pixelCount; i++) {
        edgeMagnitude[i] /= maxEdge;
    }

    // Build integral image of grayscale
    const integral = new Float32Array(pixelCount);
    for (let y = 0; y < height; y++) {
        let rowSum = 0;
        for (let x = 0; x < width; x++) {
            const idx = y * width + x;
            rowSum += gray[idx];
            integral[idx] = rowSum + (y > 0 ? integral[(y - 1) * width + x] : 0);
        }
    }

    // Helper to get sum from integral image
    function getRegionSum(x0, y0, x1, y1) {
        x0 = Math.max(0, x0);
        y0 = Math.max(0, y0);
        x1 = Math.min(width - 1, x1);
        y1 = Math.min(height - 1, y1);

        const A = (y0 > 0 && x0 > 0) ? integral[(y0 - 1) * width + (x0 - 1)] : 0;
        const B = (y0 > 0) ? integral[(y0 - 1) * width + x1] : 0;
        const C = (x0 > 0) ? integral[y1 * width + (x0 - 1)] : 0;
        const D = integral[y1 * width + x1];

        return D - B - C + A;
    }

    // Apply adaptive thresholding with edge-aware scaling
    const minBlockSize = 5;
    const maxBlockSize = baseBlockSize;

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const idx = y * width + x;
            const edgeStrength = edgeMagnitude[idx];

            // Interpolate block size: strong edge ‚Üí small block; weak edge ‚Üí large block
            const effectiveBlockSize = Math.round(
                maxBlockSize - edgeStrength * (maxBlockSize - minBlockSize)
            );

            const halfBlock = Math.floor(effectiveBlockSize / 2);
            const x0 = x - halfBlock;
            const y0 = y - halfBlock;
            const x1 = x + halfBlock;
            const y1 = y + halfBlock;

            const regionWidth = x1 - x0 + 1;
            const regionHeight = y1 - y0 + 1;
            const count = regionWidth * regionHeight;

            const regionSum = getRegionSum(x0, y0, x1, y1);
            const localMean = regionSum / count;

            const threshold = localMean - C;
            const value = gray[idx] >= threshold ? 255 : 0;

            const offset = idx * 4;
            imageData.data[offset] = imageData.data[offset + 1] = imageData.data[offset + 2] = value;
            imageData.data[offset + 3] = 255;
        }
    }

    ctx.putImageData(imageData, 0, 0);
}

function edgeAwareAdaptiveThresholdingSobel(baseBlockSize = 15, C = 10) {
    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;

    const imageData = ctx.getImageData(0, 0, width, height);
    const original = new Uint8ClampedArray(imageData.data);
    const pixelCount = width * height;

    const gray = new Float32Array(pixelCount);
    const edgeMagnitude = new Float32Array(pixelCount);

    // Convert to grayscale
    for (let i = 0; i < pixelCount; i++) {
        const r = original[i * 4];
        const g = original[i * 4 + 1];
        const b = original[i * 4 + 2];
        gray[i] = 0.299 * r + 0.587 * g + 0.114 * b;
    }

    // Compute Sobel edge magnitude
    function getPixel(x, y) {
        x = Math.max(0, Math.min(width - 1, x));
        y = Math.max(0, Math.min(height - 1, y));
        return gray[y * width + x];
    }

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const gx =
                -1 * getPixel(x - 1, y - 1) + 1 * getPixel(x + 1, y - 1) +
                -2 * getPixel(x - 1, y)     + 2 * getPixel(x + 1, y) +
                -1 * getPixel(x - 1, y + 1) + 1 * getPixel(x + 1, y + 1);

            const gy =
                -1 * getPixel(x - 1, y - 1) + -2 * getPixel(x, y - 1) + -1 * getPixel(x + 1, y - 1) +
                 1 * getPixel(x - 1, y + 1) +  2 * getPixel(x, y + 1) +  1 * getPixel(x + 1, y + 1);

            const magnitude = Math.sqrt(gx * gx + gy * gy);
            edgeMagnitude[y * width + x] = magnitude;
        }
    }

    // Normalize edgeMagnitude to [0, 1]
    const maxEdge = edgeMagnitude.reduce((max, val) => Math.max(max, val), -Infinity) || 1e-5;
    for (let i = 0; i < pixelCount; i++) {
        edgeMagnitude[i] /= maxEdge;
    }

    // Build integral image of grayscale for fast mean calculation
    const integral = new Float32Array(pixelCount);
    for (let y = 0; y < height; y++) {
        let rowSum = 0;
        for (let x = 0; x < width; x++) {
            const idx = y * width + x;
            rowSum += gray[idx];
            integral[idx] = rowSum + (y > 0 ? integral[(y - 1) * width + x] : 0);
        }
    }

    function getRegionSum(x0, y0, x1, y1) {
        x0 = Math.max(0, x0);
        y0 = Math.max(0, y0);
        x1 = Math.min(width - 1, x1);
        y1 = Math.min(height - 1, y1);

        const A = (y0 > 0 && x0 > 0) ? integral[(y0 - 1) * width + (x0 - 1)] : 0;
        const B = (y0 > 0) ? integral[(y0 - 1) * width + x1] : 0;
        const C = (x0 > 0) ? integral[y1 * width + (x0 - 1)] : 0;
        const D = integral[y1 * width + x1];

        return D - B - C + A;
    }

    // Apply edge-aware adaptive thresholding
    const minBlockSize = 5;

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const idx = y * width + x;
            const edgeStrength = edgeMagnitude[idx];

            // Stronger edge = smaller block size
            const effectiveBlockSize = Math.round(
                baseBlockSize - edgeStrength * (baseBlockSize - minBlockSize)
            );
            const halfBlock = Math.floor(effectiveBlockSize / 2);

            const x0 = x - halfBlock;
            const y0 = y - halfBlock;
            const x1 = x + halfBlock;
            const y1 = y + halfBlock;

            const regionWidth = x1 - x0 + 1;
            const regionHeight = y1 - y0 + 1;
            const count = regionWidth * regionHeight;

            const regionSum = getRegionSum(x0, y0, x1, y1);
            const localMean = regionSum / count;

            const threshold = localMean - C;
            const value = gray[idx] >= threshold ? 255 : 0;

            const offset = idx * 4;
            imageData.data[offset + 0] = value;
            imageData.data[offset + 1] = value;
            imageData.data[offset + 2] = value;
            imageData.data[offset + 3] = 255;
        }
    }

    ctx.putImageData(imageData, 0, 0);
}

function edgeAwareAdaptiveThresholdingColorPreserved(baseBlockSize = 15, C = 10) {
    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");
    const width = canvas.width;
    const height = canvas.height;

    const imageData = ctx.getImageData(0, 0, width, height);
    const original = new Uint8ClampedArray(imageData.data);
    const pixelCount = width * height;

    const gray = new Float32Array(pixelCount);
    const edgeMagnitude = new Float32Array(pixelCount);

    // Convert to grayscale
    for (let i = 0; i < pixelCount; i++) {
        const r = original[i * 4];
        const g = original[i * 4 + 1];
        const b = original[i * 4 + 2];
        gray[i] = 0.299 * r + 0.587 * g + 0.114 * b;
    }

    // Compute Sobel edge magnitude
    function getPixel(x, y) {
        x = Math.max(0, Math.min(width - 1, x));
        y = Math.max(0, Math.min(height - 1, y));
        return gray[y * width + x];
    }

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const gx =
                -1 * getPixel(x - 1, y - 1) + 1 * getPixel(x + 1, y - 1) +
                -2 * getPixel(x - 1, y)     + 2 * getPixel(x + 1, y) +
                -1 * getPixel(x - 1, y + 1) + 1 * getPixel(x + 1, y + 1);

            const gy =
                -1 * getPixel(x - 1, y - 1) + -2 * getPixel(x, y - 1) + -1 * getPixel(x + 1, y - 1) +
                 1 * getPixel(x - 1, y + 1) +  2 * getPixel(x, y + 1) +  1 * getPixel(x + 1, y + 1);

            const magnitude = Math.sqrt(gx * gx + gy * gy);
            edgeMagnitude[y * width + x] = magnitude;
        }
    }

    // Normalize edgeMagnitude to [0, 1]
    const maxEdge = edgeMagnitude.reduce((max, val) => Math.max(max, val), -Infinity) || 1e-5;
    for (let i = 0; i < pixelCount; i++) {
        edgeMagnitude[i] /= maxEdge;
    }

    // Build integral image of grayscale
    const integral = new Float32Array(pixelCount);
    for (let y = 0; y < height; y++) {
        let rowSum = 0;
        for (let x = 0; x < width; x++) {
            const idx = y * width + x;
            rowSum += gray[idx];
            integral[idx] = rowSum + (y > 0 ? integral[(y - 1) * width + x] : 0);
        }
    }

    function getRegionSum(x0, y0, x1, y1) {
        x0 = Math.max(0, x0);
        y0 = Math.max(0, y0);
        x1 = Math.min(width - 1, x1);
        y1 = Math.min(height - 1, y1);

        const A = (y0 > 0 && x0 > 0) ? integral[(y0 - 1) * width + (x0 - 1)] : 0;
        const B = (y0 > 0) ? integral[(y0 - 1) * width + x1] : 0;
        const C = (x0 > 0) ? integral[y1 * width + (x0 - 1)] : 0;
        const D = integral[y1 * width + x1];

        return D - B - C + A;
    }

    // Apply adaptive thresholding, preserving color
    const minBlockSize = 5;

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const idx = y * width + x;
            const edgeStrength = edgeMagnitude[idx];

            // Smaller window for sharper edges
            const effectiveBlockSize = Math.round(
                baseBlockSize - edgeStrength * (baseBlockSize - minBlockSize)
            );
            const halfBlock = Math.floor(effectiveBlockSize / 2);

            const x0 = x - halfBlock;
            const y0 = y - halfBlock;
            const x1 = x + halfBlock;
            const y1 = y + halfBlock;

            const regionWidth = x1 - x0 + 1;
            const regionHeight = y1 - y0 + 1;
            const count = regionWidth * regionHeight;

            const regionSum = getRegionSum(x0, y0, x1, y1);
            const localMean = regionSum / count;

            const threshold = localMean - C;
            const pixelGray = gray[idx];

            const offset = idx * 4;

            if (pixelGray >= threshold) {
                // Keep original color
                imageData.data[offset + 0] = original[offset + 0];
                imageData.data[offset + 1] = original[offset + 1];
                imageData.data[offset + 2] = original[offset + 2];
            } else {
                // Dim / mask color (or set to white/black)
                const dimFactor = 0.3;
                imageData.data[offset + 0] = original[offset + 0] * dimFactor;
                imageData.data[offset + 1] = original[offset + 1] * dimFactor;
                imageData.data[offset + 2] = original[offset + 2] * dimFactor;
            }

            imageData.data[offset + 3] = 255;
        }
    }

    ctx.putImageData(imageData, 0, 0);
}

function autoTrimWhiteSpace(canvas = document.querySelector("canvas")) {
  if (!canvas) {
    console.error("Canvas element not found.");
    return;
  }

  const ctx = canvas.getContext("2d");
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data;

  let top = null, bottom = null, left = null, right = null;

  for (let y = 0; y < canvas.height; y++) {
    for (let x = 0; x < canvas.width; x++) {
      const index = (y * canvas.width + x) * 4;
      const r = data[index];
      const g = data[index + 1];
      const b = data[index + 2];
      const a = data[index + 3];

      // Consider pixel "non-white" if it's not almost pure white (tolerance: 250+)
      if (!(r > 250 && g > 250 && b > 250 && a > 0)) {
        if (top === null || y < top) top = y;
        if (bottom === null || y > bottom) bottom = y;
        if (left === null || x < left) left = x;
        if (right === null || x > right) right = x;
      }
    }
  }

  if (top === null) {
    console.warn("No non-white content found. Skipping trim.");
    return;
  }

  const trimmedWidth = right - left + 1;
  const trimmedHeight = bottom - top + 1;

  const trimmedData = ctx.getImageData(left, top, trimmedWidth, trimmedHeight);

  // Resize canvas and draw the trimmed image
  canvas.width = trimmedWidth;
  canvas.height = trimmedHeight;
  ctx.putImageData(trimmedData, 0, 0);
}

document.querySelector('#heightresize').addEventListener("click", function(){

  document.querySelectorAll("img").forEach(function(e){
    e.style.height = "285mm";
    e.style.paddingTop = "0.1in";
});

})

function contrastStretchingWithHistogramClipping(canvas = document.querySelector("canvas"), clipPercent = 1) {
  if (!canvas) {
    console.error("Canvas element not found.");
    return;
  }

  const ctx = canvas.getContext("2d");
  if (!ctx) {
    console.error("2D context not available.");
    return;
  }

  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imageData.data;
  const totalPixels = data.length / 4;

  // Helper to get sorted intensities for a given channel index (0: R, 1: G, 2: B)
  function getSortedChannelData(channelIndex) {
    const channelData = [];
    for (let i = channelIndex; i < data.length; i += 4) {
      channelData.push(data[i]);
    }
    channelData.sort((a, b) => a - b);
    return channelData;
  }

  // Calculate clipping bounds based on clipPercent for each channel
  function getClipBounds(sortedData) {
    const clipCount = Math.floor((clipPercent / 100) * sortedData.length);
    const lowBound = sortedData[clipCount];
    const highBound = sortedData[sortedData.length - 1 - clipCount];
    return { lowBound, highBound };
  }

  const rSorted = getSortedChannelData(0);
  const gSorted = getSortedChannelData(1);
  const bSorted = getSortedChannelData(2);

  const rBounds = getClipBounds(rSorted);
  const gBounds = getClipBounds(gSorted);
  const bBounds = getClipBounds(bSorted);

  // Stretch each channel using clipped min/max values
  function stretchValue(value, minVal, maxVal) {
    if (value <= minVal) return 0;
    if (value >= maxVal) return 255;
    return Math.round(((value - minVal) * 255) / (maxVal - minVal));
  }

  for (let i = 0; i < data.length; i += 4) {
    data[i] = stretchValue(data[i], rBounds.lowBound, rBounds.highBound);
    data[i + 1] = stretchValue(data[i + 1], gBounds.lowBound, gBounds.highBound);
    data[i + 2] = stretchValue(data[i + 2], bBounds.lowBound, bBounds.highBound);
    // Alpha remains unchanged
  }

  ctx.putImageData(imageData, 0, 0);
}


  </script>
  <h1>Cache Locally</h1>
  <p>This PWA accepts shared content from Android.</p>

  <!-- üîò Custom Install Button -->
  <button id="installBtn" style="display:none;">Install App</button>

  <h1>Received Shared Content</h1>
  <div id="output"></div>

  <script>
    async function getFormData() {
      const formData = await navigator?.serviceWorker?.ready.then(reg => {
        reg.navigationPreload?.getState();
      });

      if (!formData) {
        console.warn("No preload form data.");
        return;
      }

      const data = await formData.formData();
      const title = data.get('title');
      const text = data.get('text');
      const url = data.get('url');
      const file = data.get('media');

      const output = document.getElementById('output');
      output.innerHTML = `
        <p><strong>Title:</strong> ${title}</p>
        <p><strong>Text:</strong> ${text}</p>
        <p><strong>URL:</strong> ${url}</p>
      `;

      if (file && file.type.startsWith('image/')) {
        const img = document.createElement('img');
        img.src = URL.createObjectURL(file);
        img.style.maxWidth = '300px';
        output.appendChild(img);
      }
    }

    window.addEventListener('DOMContentLoaded', getFormData);
  </script>
  
  <script>
    if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("/service-worker.js")
    .then(() => console.log("SW registered"))
    .catch(err => console.error("SW registration failed:", err));
}

    // Handle install prompt
    let deferredPrompt;
    const installBtn = document.getElementById('installBtn');

    window.addEventListener('beforeinstallprompt', (e) => {
      // Stop the automatic prompt
      e.preventDefault();
      deferredPrompt = e;

      // Show the custom install button
      installBtn.style.display = 'inline';

      installBtn.addEventListener('click', () => {
        installBtn.style.display = 'none';
        deferredPrompt.prompt();

        deferredPrompt.userChoice.then((choiceResult) => {
          if (choiceResult.outcome === 'accepted') {
            console.log('User accepted the install prompt');
          } else {
            console.log('User dismissed the install prompt');
          }
          deferredPrompt = null;
        });
      });
    });
  </script>
</body>
</html>





